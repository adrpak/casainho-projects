
main.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003270  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .init         0000000c  00003270  00003270  0000b270  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .fini         0000000c  0000327c  0000327c  0000b27c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .eh_frame     00000004  00003288  00003288  0000b288  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .data         0000000c  10000000  0000328c  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .init_array   00000004  1000000c  00003298  0001000c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .fini_array   00000004  10000010  0000329c  00010010  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .jcr          00000004  10000014  000032a0  00010014  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          00004d74  10000018  000032a4  00010018  2**3
                  ALLOC
  9 .ARM.attributes 00000025  00000000  00000000  00010018  2**0
                  CONTENTS, READONLY
 10 .comment      000001ce  00000000  00000000  0001003d  2**0
                  CONTENTS, READONLY
 11 .debug_abbrev 00000d6b  00000000  00000000  0001020b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   00003d40  00000000  00000000  00010f76  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00002ade  00000000  00000000  00014cb6  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_macinfo 000451f4  00000000  00000000  00017794  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00000df0  00000000  00000000  0005c988  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    00001564  00000000  00000000  0005d778  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubnames 0000083b  00000000  00000000  0005ecdc  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_aranges 00000478  00000000  00000000  0005f517  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_ranges 00000420  00000000  00000000  0005f98f  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_str    000018c5  00000000  00000000  0005fdaf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_NVIC_Handler_Functions>:
       0:	f0 7f 00 10 d9 0a 00 00 4d 0b 00 00 4d 0b 00 00     ........M...M...
      10:	4d 0b 00 00 4d 0b 00 00 4d 0b 00 00 00 00 00 00     M...M...M.......
      20:	00 00 00 00 00 00 00 00 00 00 00 00 cd 2d 00 00     .............-..
      30:	4d 0b 00 00 00 00 00 00 d9 2e 00 00 15 2f 00 00     M............/..
      40:	4d 0b 00 00 4d 0b 00 00 4d 0b 00 00 4d 0b 00 00     M...M...M...M...
      50:	4d 0b 00 00 4d 0b 00 00 4d 0b 00 00 4d 0b 00 00     M...M...M...M...
      60:	4d 0b 00 00 4d 0b 00 00 4d 0b 00 00 4d 0b 00 00     M...M...M...M...
      70:	4d 0b 00 00 4d 0b 00 00 4d 0b 00 00 4d 0b 00 00     M...M...M...M...
      80:	4d 0b 00 00 4d 0b 00 00 4d 0b 00 00 4d 0b 00 00     M...M...M...M...
      90:	4d 0b 00 00 4d 0b 00 00 4d 0b 00 00 4d 0b 00 00     M...M...M...M...
      a0:	4d 0b 00 00 4d 0b 00 00 4d 0b 00 00 4d 0b 00 00     M...M...M...M...
      b0:	4d 0b 00 00 4d 0b 00 00 4d 0b 00 00 4d 0b 00 00     M...M...M...M...
      c0:	4d 0b 00 00 4d 0b 00 00 4d 0b 00 00                 M...M...M...

000000cc <__do_global_dtors_aux>:
      cc:	b510      	push	{r4, lr}
      ce:	f240 0418 	movw	r4, #24
      d2:	f2c1 0400 	movt	r4, #4096	; 0x1000
      d6:	7823      	ldrb	r3, [r4, #0]
      d8:	b963      	cbnz	r3, f4 <__do_global_dtors_aux+0x28>
      da:	f240 0000 	movw	r0, #0
      de:	f2c0 0000 	movt	r0, #0
      e2:	b128      	cbz	r0, f0 <__do_global_dtors_aux+0x24>
      e4:	f243 2088 	movw	r0, #12936	; 0x3288
      e8:	f2c0 0000 	movt	r0, #0
      ec:	f3af 8000 	nop.w
      f0:	2101      	movs	r1, #1
      f2:	7021      	strb	r1, [r4, #0]
      f4:	bd10      	pop	{r4, pc}
      f6:	bf00      	nop

000000f8 <frame_dummy>:
      f8:	b508      	push	{r3, lr}
      fa:	f240 0300 	movw	r3, #0
      fe:	f2c0 0300 	movt	r3, #0
     102:	b14b      	cbz	r3, 118 <frame_dummy+0x20>
     104:	f243 2088 	movw	r0, #12936	; 0x3288
     108:	f240 011c 	movw	r1, #28
     10c:	f2c0 0000 	movt	r0, #0
     110:	f2c1 0100 	movt	r1, #4096	; 0x1000
     114:	f3af 8000 	nop.w
     118:	f240 0014 	movw	r0, #20
     11c:	f2c1 0000 	movt	r0, #4096	; 0x1000
     120:	6801      	ldr	r1, [r0, #0]
     122:	b129      	cbz	r1, 130 <frame_dummy+0x38>
     124:	f240 0300 	movw	r3, #0
     128:	f2c0 0300 	movt	r3, #0
     12c:	b103      	cbz	r3, 130 <frame_dummy+0x38>
     12e:	4798      	blx	r3
     130:	bd08      	pop	{r3, pc}
     132:	bf00      	nop

00000134 <blink_led>:
/* dev_175x will be __TRUE is code is running on an LPC175x device */
char dev_175x;

/*-----------------------------------------------------------*/
void blink_led (void)
{
     134:	b480      	push	{r7}
     136:	af00      	add	r7, sp, #0
    /* Enable LED pin as output */
    LPC_GPIO1->FIODIR = LED_PIN;
     138:	f24c 0320 	movw	r3, #49184	; 0xc020
     13c:	f2c2 0309 	movt	r3, #8201	; 0x2009
     140:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
     144:	601a      	str	r2, [r3, #0]

    for(;;)
    {
        /* Blink the LED on pin */
        if (LPC_GPIO1->FIOPIN & (LED_PIN))
     146:	f24c 0320 	movw	r3, #49184	; 0xc020
     14a:	f2c2 0309 	movt	r3, #8201	; 0x2009
     14e:	695b      	ldr	r3, [r3, #20]
     150:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
     154:	2b00      	cmp	r3, #0
     156:	d00c      	beq.n	172 <blink_led+0x3e>
        {
            /* LED off */
            LPC_GPIO1->FIOPIN &= ~LED_PIN;
     158:	f24c 0320 	movw	r3, #49184	; 0xc020
     15c:	f2c2 0309 	movt	r3, #8201	; 0x2009
     160:	f24c 0220 	movw	r2, #49184	; 0xc020
     164:	f2c2 0209 	movt	r2, #8201	; 0x2009
     168:	6952      	ldr	r2, [r2, #20]
     16a:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
     16e:	615a      	str	r2, [r3, #20]
        else
        {
            /* LED on */
            LPC_GPIO1->FIOPIN |= LED_PIN;
        }
    }
     170:	e7e9      	b.n	146 <blink_led+0x12>
        }

        else
        {
            /* LED on */
            LPC_GPIO1->FIOPIN |= LED_PIN;
     172:	f24c 0320 	movw	r3, #49184	; 0xc020
     176:	f2c2 0309 	movt	r3, #8201	; 0x2009
     17a:	f24c 0220 	movw	r2, #49184	; 0xc020
     17e:	f2c2 0209 	movt	r2, #8201	; 0x2009
     182:	6952      	ldr	r2, [r2, #20]
     184:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
     188:	615a      	str	r2, [r3, #20]
        }
    }
     18a:	e7dc      	b.n	146 <blink_led+0x12>

0000018c <main>:
}


int main( void )
{
     18c:	b580      	push	{r7, lr}
     18e:	b084      	sub	sp, #16
     190:	af04      	add	r7, sp, #16
	/* Configure the hardware for use by this demo. */
	prvSetupHardware();
     192:	f000 f81f 	bl	1d4 <prvSetupHardware>

    /* Create the blink led task. */
    xTaskCreate( blink_led, ( signed char * ) "LED", configMINIMAL_STACK_SIZE, ( void * ) NULL, tskIDLE_PRIORITY, NULL );
     196:	f240 1235 	movw	r2, #309	; 0x135
     19a:	f2c0 0200 	movt	r2, #0
     19e:	f243 2354 	movw	r3, #12884	; 0x3254
     1a2:	f2c0 0300 	movt	r3, #0
     1a6:	f04f 0100 	mov.w	r1, #0
     1aa:	9100      	str	r1, [sp, #0]
     1ac:	f04f 0100 	mov.w	r1, #0
     1b0:	9101      	str	r1, [sp, #4]
     1b2:	f04f 0100 	mov.w	r1, #0
     1b6:	9102      	str	r1, [sp, #8]
     1b8:	f04f 0100 	mov.w	r1, #0
     1bc:	9103      	str	r1, [sp, #12]
     1be:	4610      	mov	r0, r2
     1c0:	4619      	mov	r1, r3
     1c2:	f04f 0250 	mov.w	r2, #80	; 0x50
     1c6:	f04f 0300 	mov.w	r3, #0
     1ca:	f001 fcd9 	bl	1b80 <xTaskGenericCreate>

    /* Start the scheduler. */
	vTaskStartScheduler();
     1ce:	f002 f83d 	bl	224c <vTaskStartScheduler>

    /* Will only get here if there was insufficient memory to create the idle
    task.  The idle task is created within vTaskStartScheduler(). */
	for( ;; );
     1d2:	e7fe      	b.n	1d2 <main+0x46>

000001d4 <prvSetupHardware>:
}
/*-----------------------------------------------------------*/

void prvSetupHardware( void )
{
     1d4:	b580      	push	{r7, lr}
     1d6:	b084      	sub	sp, #16
     1d8:	af00      	add	r7, sp, #0
	typedef void (*IAP)(U32 *cmd, U32 *res);
	U32 pb[2];
	IAP iap_entry = (IAP)0x1FFF1FF1;
     1da:	f641 73f1 	movw	r3, #8177	; 0x1ff1
     1de:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     1e2:	60fb      	str	r3, [r7, #12]

	/* Disable peripherals power. */
	LPC_SC->PCONP = 0;
     1e4:	f24c 0300 	movw	r3, #49152	; 0xc000
     1e8:	f2c4 030f 	movt	r3, #16399	; 0x400f
     1ec:	f04f 0200 	mov.w	r2, #0
     1f0:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4

	/* Enable GPIO power. */
	LPC_SC->PCONP = PCONP_PCGPIO;
     1f4:	f24c 0300 	movw	r3, #49152	; 0xc000
     1f8:	f2c4 030f 	movt	r3, #16399	; 0x400f
     1fc:	f44f 4200 	mov.w	r2, #32768	; 0x8000
     200:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4

	/* Disable TPIU. */
	LPC_PINCON->PINSEL10 = 0;
     204:	f24c 0300 	movw	r3, #49152	; 0xc000
     208:	f2c4 0302 	movt	r3, #16386	; 0x4002
     20c:	f04f 0200 	mov.w	r2, #0
     210:	629a      	str	r2, [r3, #40]	; 0x28

	if ( LPC_SC->PLL0STAT & ( 1 << 25 ) )
     212:	f24c 0300 	movw	r3, #49152	; 0xc000
     216:	f2c4 030f 	movt	r3, #16399	; 0x400f
     21a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
     21e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
     222:	2b00      	cmp	r3, #0
     224:	d017      	beq.n	256 <prvSetupHardware+0x82>
	{
		/* Enable PLL, disconnected. */
		LPC_SC->PLL0CON = 1;			
     226:	f24c 0300 	movw	r3, #49152	; 0xc000
     22a:	f2c4 030f 	movt	r3, #16399	; 0x400f
     22e:	f04f 0201 	mov.w	r2, #1
     232:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		LPC_SC->PLL0FEED = PLLFEED_FEED1;
     236:	f24c 0300 	movw	r3, #49152	; 0xc000
     23a:	f2c4 030f 	movt	r3, #16399	; 0x400f
     23e:	f04f 02aa 	mov.w	r2, #170	; 0xaa
     242:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
		LPC_SC->PLL0FEED = PLLFEED_FEED2;
     246:	f24c 0300 	movw	r3, #49152	; 0xc000
     24a:	f2c4 030f 	movt	r3, #16399	; 0x400f
     24e:	f04f 0255 	mov.w	r2, #85	; 0x55
     252:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	}
	
	/* Disable PLL, disconnected. */
	LPC_SC->PLL0CON = 0;				
     256:	f24c 0300 	movw	r3, #49152	; 0xc000
     25a:	f2c4 030f 	movt	r3, #16399	; 0x400f
     25e:	f04f 0200 	mov.w	r2, #0
     262:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	LPC_SC->PLL0FEED = PLLFEED_FEED1;
     266:	f24c 0300 	movw	r3, #49152	; 0xc000
     26a:	f2c4 030f 	movt	r3, #16399	; 0x400f
     26e:	f04f 02aa 	mov.w	r2, #170	; 0xaa
     272:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	LPC_SC->PLL0FEED = PLLFEED_FEED2;
     276:	f24c 0300 	movw	r3, #49152	; 0xc000
     27a:	f2c4 030f 	movt	r3, #16399	; 0x400f
     27e:	f04f 0255 	mov.w	r2, #85	; 0x55
     282:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	    
	/* Enable main OSC. */
	LPC_SC->SCS |= 0x20;			
     286:	f24c 0300 	movw	r3, #49152	; 0xc000
     28a:	f2c4 030f 	movt	r3, #16399	; 0x400f
     28e:	f24c 0200 	movw	r2, #49152	; 0xc000
     292:	f2c4 020f 	movt	r2, #16399	; 0x400f
     296:	f8d2 21a0 	ldr.w	r2, [r2, #416]	; 0x1a0
     29a:	f042 0220 	orr.w	r2, r2, #32
     29e:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
	while( !( LPC_SC->SCS & 0x40 ) );
     2a2:	f24c 0300 	movw	r3, #49152	; 0xc000
     2a6:	f2c4 030f 	movt	r3, #16399	; 0x400f
     2aa:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
     2ae:	f003 0340 	and.w	r3, r3, #64	; 0x40
     2b2:	2b00      	cmp	r3, #0
     2b4:	d0f5      	beq.n	2a2 <prvSetupHardware+0xce>
	
	/* select main OSC, 12MHz, as the PLL clock source. */
	LPC_SC->CLKSRCSEL = 0x1;		
     2b6:	f24c 0300 	movw	r3, #49152	; 0xc000
     2ba:	f2c4 030f 	movt	r3, #16399	; 0x400f
     2be:	f04f 0201 	mov.w	r2, #1
     2c2:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
	
	LPC_SC->PLL0CFG = 0x20031;
     2c6:	f24c 0300 	movw	r3, #49152	; 0xc000
     2ca:	f2c4 030f 	movt	r3, #16399	; 0x400f
     2ce:	f240 0231 	movw	r2, #49	; 0x31
     2d2:	f2c0 0202 	movt	r2, #2
     2d6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	// 0x20031 = 10 0 000000000110001 ==> NSEL0=2  MSEL0=49
	LPC_SC->PLL0FEED = PLLFEED_FEED1;
     2da:	f24c 0300 	movw	r3, #49152	; 0xc000
     2de:	f2c4 030f 	movt	r3, #16399	; 0x400f
     2e2:	f04f 02aa 	mov.w	r2, #170	; 0xaa
     2e6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	LPC_SC->PLL0FEED = PLLFEED_FEED2;
     2ea:	f24c 0300 	movw	r3, #49152	; 0xc000
     2ee:	f2c4 030f 	movt	r3, #16399	; 0x400f
     2f2:	f04f 0255 	mov.w	r2, #85	; 0x55
     2f6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	      
	/* Enable PLL, disconnected. */
	LPC_SC->PLL0CON = 1;				
     2fa:	f24c 0300 	movw	r3, #49152	; 0xc000
     2fe:	f2c4 030f 	movt	r3, #16399	; 0x400f
     302:	f04f 0201 	mov.w	r2, #1
     306:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	LPC_SC->PLL0FEED = PLLFEED_FEED1;
     30a:	f24c 0300 	movw	r3, #49152	; 0xc000
     30e:	f2c4 030f 	movt	r3, #16399	; 0x400f
     312:	f04f 02aa 	mov.w	r2, #170	; 0xaa
     316:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	LPC_SC->PLL0FEED = PLLFEED_FEED2;
     31a:	f24c 0300 	movw	r3, #49152	; 0xc000
     31e:	f2c4 030f 	movt	r3, #16399	; 0x400f
     322:	f04f 0255 	mov.w	r2, #85	; 0x55
     326:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	
	/* Set clock divider. */
	LPC_SC->CCLKCFG = 0x03;
     32a:	f24c 0300 	movw	r3, #49152	; 0xc000
     32e:	f2c4 030f 	movt	r3, #16399	; 0x400f
     332:	f04f 0203 	mov.w	r2, #3
     336:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	
	/* Configure flash accelerator. */
	LPC_SC->FLASHCFG = 0x403a;
     33a:	f24c 0300 	movw	r3, #49152	; 0xc000
     33e:	f2c4 030f 	movt	r3, #16399	; 0x400f
     342:	f244 023a 	movw	r2, #16442	; 0x403a
     346:	601a      	str	r2, [r3, #0]
	
	/* Check lock bit status. */
	while( ( ( LPC_SC->PLL0STAT & ( 1 << 26 ) ) == 0 ) );	
     348:	f24c 0300 	movw	r3, #49152	; 0xc000
     34c:	f2c4 030f 	movt	r3, #16399	; 0x400f
     350:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
     354:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
     358:	2b00      	cmp	r3, #0
     35a:	d0f5      	beq.n	348 <prvSetupHardware+0x174>
	    
	/* Enable and connect. */
	LPC_SC->PLL0CON = 3;				
     35c:	f24c 0300 	movw	r3, #49152	; 0xc000
     360:	f2c4 030f 	movt	r3, #16399	; 0x400f
     364:	f04f 0203 	mov.w	r2, #3
     368:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	LPC_SC->PLL0FEED = PLLFEED_FEED1;
     36c:	f24c 0300 	movw	r3, #49152	; 0xc000
     370:	f2c4 030f 	movt	r3, #16399	; 0x400f
     374:	f04f 02aa 	mov.w	r2, #170	; 0xaa
     378:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	LPC_SC->PLL0FEED = PLLFEED_FEED2;
     37c:	f24c 0300 	movw	r3, #49152	; 0xc000
     380:	f2c4 030f 	movt	r3, #16399	; 0x400f
     384:	f04f 0255 	mov.w	r2, #85	; 0x55
     388:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	while( ( ( LPC_SC->PLL0STAT & ( 1 << 25 ) ) == 0 ) );	
     38c:	f24c 0300 	movw	r3, #49152	; 0xc000
     390:	f2c4 030f 	movt	r3, #16399	; 0x400f
     394:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
     398:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
     39c:	2b00      	cmp	r3, #0
     39e:	d0f5      	beq.n	38c <prvSetupHardware+0x1b8>



	/* Configure the clock for the USB. */

	if( LPC_SC->PLL1STAT & ( 1 << 9 ) )
     3a0:	f24c 0300 	movw	r3, #49152	; 0xc000
     3a4:	f2c4 030f 	movt	r3, #16399	; 0x400f
     3a8:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
     3ac:	f403 7300 	and.w	r3, r3, #512	; 0x200
     3b0:	2b00      	cmp	r3, #0
     3b2:	d017      	beq.n	3e4 <prvSetupHardware+0x210>
	{
		/* Enable PLL, disconnected. */
		LPC_SC->PLL1CON = 1;			
     3b4:	f24c 0300 	movw	r3, #49152	; 0xc000
     3b8:	f2c4 030f 	movt	r3, #16399	; 0x400f
     3bc:	f04f 0201 	mov.w	r2, #1
     3c0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
		LPC_SC->PLL1FEED = PLLFEED_FEED1;
     3c4:	f24c 0300 	movw	r3, #49152	; 0xc000
     3c8:	f2c4 030f 	movt	r3, #16399	; 0x400f
     3cc:	f04f 02aa 	mov.w	r2, #170	; 0xaa
     3d0:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
		LPC_SC->PLL1FEED = PLLFEED_FEED2;
     3d4:	f24c 0300 	movw	r3, #49152	; 0xc000
     3d8:	f2c4 030f 	movt	r3, #16399	; 0x400f
     3dc:	f04f 0255 	mov.w	r2, #85	; 0x55
     3e0:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
	}

	/* Disable PLL, disconnected. */
	LPC_SC->PLL1CON = 0;				
     3e4:	f24c 0300 	movw	r3, #49152	; 0xc000
     3e8:	f2c4 030f 	movt	r3, #16399	; 0x400f
     3ec:	f04f 0200 	mov.w	r2, #0
     3f0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	LPC_SC->PLL1FEED = PLLFEED_FEED1;
     3f4:	f24c 0300 	movw	r3, #49152	; 0xc000
     3f8:	f2c4 030f 	movt	r3, #16399	; 0x400f
     3fc:	f04f 02aa 	mov.w	r2, #170	; 0xaa
     400:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
	LPC_SC->PLL1FEED = PLLFEED_FEED2;
     404:	f24c 0300 	movw	r3, #49152	; 0xc000
     408:	f2c4 030f 	movt	r3, #16399	; 0x400f
     40c:	f04f 0255 	mov.w	r2, #85	; 0x55
     410:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac

	LPC_SC->PLL1CFG = 0x23;
     414:	f24c 0300 	movw	r3, #49152	; 0xc000
     418:	f2c4 030f 	movt	r3, #16399	; 0x400f
     41c:	f04f 0223 	mov.w	r2, #35	; 0x23
     420:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
	LPC_SC->PLL1FEED = PLLFEED_FEED1;
     424:	f24c 0300 	movw	r3, #49152	; 0xc000
     428:	f2c4 030f 	movt	r3, #16399	; 0x400f
     42c:	f04f 02aa 	mov.w	r2, #170	; 0xaa
     430:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
	LPC_SC->PLL1FEED = PLLFEED_FEED2;
     434:	f24c 0300 	movw	r3, #49152	; 0xc000
     438:	f2c4 030f 	movt	r3, #16399	; 0x400f
     43c:	f04f 0255 	mov.w	r2, #85	; 0x55
     440:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac

	/* Enable PLL, disconnected. */
	LPC_SC->PLL1CON = 1;				
     444:	f24c 0300 	movw	r3, #49152	; 0xc000
     448:	f2c4 030f 	movt	r3, #16399	; 0x400f
     44c:	f04f 0201 	mov.w	r2, #1
     450:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	LPC_SC->PLL1FEED = PLLFEED_FEED1;
     454:	f24c 0300 	movw	r3, #49152	; 0xc000
     458:	f2c4 030f 	movt	r3, #16399	; 0x400f
     45c:	f04f 02aa 	mov.w	r2, #170	; 0xaa
     460:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
	LPC_SC->PLL1FEED = PLLFEED_FEED2;
     464:	f24c 0300 	movw	r3, #49152	; 0xc000
     468:	f2c4 030f 	movt	r3, #16399	; 0x400f
     46c:	f04f 0255 	mov.w	r2, #85	; 0x55
     470:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
	while( ( ( LPC_SC->PLL1STAT & ( 1 << 10 ) ) == 0 ) );
     474:	f24c 0300 	movw	r3, #49152	; 0xc000
     478:	f2c4 030f 	movt	r3, #16399	; 0x400f
     47c:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
     480:	f403 6380 	and.w	r3, r3, #1024	; 0x400
     484:	2b00      	cmp	r3, #0
     486:	d0f5      	beq.n	474 <prvSetupHardware+0x2a0>

	/* Enable and connect. */
	LPC_SC->PLL1CON = 3;				
     488:	f24c 0300 	movw	r3, #49152	; 0xc000
     48c:	f2c4 030f 	movt	r3, #16399	; 0x400f
     490:	f04f 0203 	mov.w	r2, #3
     494:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	LPC_SC->PLL1FEED = PLLFEED_FEED1;
     498:	f24c 0300 	movw	r3, #49152	; 0xc000
     49c:	f2c4 030f 	movt	r3, #16399	; 0x400f
     4a0:	f04f 02aa 	mov.w	r2, #170	; 0xaa
     4a4:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
	LPC_SC->PLL1FEED = PLLFEED_FEED2;
     4a8:	f24c 0300 	movw	r3, #49152	; 0xc000
     4ac:	f2c4 030f 	movt	r3, #16399	; 0x400f
     4b0:	f04f 0255 	mov.w	r2, #85	; 0x55
     4b4:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
	while( ( ( LPC_SC->PLL1STAT & ( 1 << 9 ) ) == 0 ) );
     4b8:	f24c 0300 	movw	r3, #49152	; 0xc000
     4bc:	f2c4 030f 	movt	r3, #16399	; 0x400f
     4c0:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
     4c4:	f403 7300 	and.w	r3, r3, #512	; 0x200
     4c8:	2b00      	cmp	r3, #0
     4ca:	d0f5      	beq.n	4b8 <prvSetupHardware+0x2e4>

	/*  Setup the peripheral bus to be the same as the PLL output (64 MHz). */
	LPC_SC->PCLKSEL0 = 0x05555555;
     4cc:	f24c 0300 	movw	r3, #49152	; 0xc000
     4d0:	f2c4 030f 	movt	r3, #16399	; 0x400f
     4d4:	f245 5255 	movw	r2, #21845	; 0x5555
     4d8:	f2c0 5255 	movt	r2, #1365	; 0x555
     4dc:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8

	/* Determine if using the LPC1758 model.
	 * This is critical for ethernet support as the LPC1758
	 * does not have a functional MIIM - AN10859 */
	dev_175x = __FALSE;
     4e0:	f644 5338 	movw	r3, #19768	; 0x4d38
     4e4:	f2c1 0300 	movt	r3, #4096	; 0x1000
     4e8:	f04f 0200 	mov.w	r2, #0
     4ec:	701a      	strb	r2, [r3, #0]
	/* Read device ID with IAP */
	pb[0] = 54;
     4ee:	f04f 0336 	mov.w	r3, #54	; 0x36
     4f2:	607b      	str	r3, [r7, #4]
	iap_entry (&pb[0], &pb[0]);
     4f4:	f107 0104 	add.w	r1, r7, #4
     4f8:	f107 0204 	add.w	r2, r7, #4
     4fc:	68fb      	ldr	r3, [r7, #12]
     4fe:	4608      	mov	r0, r1
     500:	4611      	mov	r1, r2
     502:	4798      	blx	r3
	if ((pb[1] >> 24) == 0x25) {
     504:	68bb      	ldr	r3, [r7, #8]
     506:	ea4f 6313 	mov.w	r3, r3, lsr #24
     50a:	2b25      	cmp	r3, #37	; 0x25
     50c:	d106      	bne.n	51c <prvSetupHardware+0x348>
		dev_175x = __TRUE;
     50e:	f644 5338 	movw	r3, #19768	; 0x4d38
     512:	f2c1 0300 	movt	r3, #4096	; 0x1000
     516:	f04f 0201 	mov.w	r2, #1
     51a:	701a      	strb	r2, [r3, #0]
	}
}
     51c:	f107 0710 	add.w	r7, r7, #16
     520:	46bd      	mov	sp, r7
     522:	bd80      	pop	{r7, pc}

00000524 <vApplicationStackOverflowHook>:
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName )
{
     524:	b480      	push	{r7}
     526:	b083      	sub	sp, #12
     528:	af00      	add	r7, sp, #0
     52a:	6078      	str	r0, [r7, #4]
     52c:	6039      	str	r1, [r7, #0]
	/* This function will get called if a task overflows its stack. */

	( void ) pxTask;
	( void ) pcTaskName;

	for( ;; );
     52e:	e7fe      	b.n	52e <vApplicationStackOverflowHook+0xa>

00000530 <vConfigureTimerForRunTimeStats>:
}
/*-----------------------------------------------------------*/

void vConfigureTimerForRunTimeStats (void)
{
     530:	b480      	push	{r7}
     532:	af00      	add	r7, sp, #0
}
     534:	46bd      	mov	sp, r7
     536:	bc80      	pop	{r7}
     538:	4770      	bx	lr
     53a:	bf00      	nop

0000053c <vApplicationTickHook>:

void vApplicationTickHook (void)
{
     53c:	b480      	push	{r7}
     53e:	af00      	add	r7, sp, #0
    for( ;; ) ;
     540:	e7fe      	b.n	540 <vApplicationTickHook+0x4>
     542:	bf00      	nop

00000544 <printchar>:
#define putchar(c) c

#include <stdarg.h>

static void printchar(char **str, int c)
{
     544:	b480      	push	{r7}
     546:	b083      	sub	sp, #12
     548:	af00      	add	r7, sp, #0
     54a:	6078      	str	r0, [r7, #4]
     54c:	6039      	str	r1, [r7, #0]
	//extern int putchar(int c);
	
	if (str) {
     54e:	687b      	ldr	r3, [r7, #4]
     550:	2b00      	cmp	r3, #0
     552:	d00a      	beq.n	56a <printchar+0x26>
		**str = (char)c;
     554:	687b      	ldr	r3, [r7, #4]
     556:	681b      	ldr	r3, [r3, #0]
     558:	683a      	ldr	r2, [r7, #0]
     55a:	b2d2      	uxtb	r2, r2
     55c:	701a      	strb	r2, [r3, #0]
		++(*str);
     55e:	687b      	ldr	r3, [r7, #4]
     560:	681b      	ldr	r3, [r3, #0]
     562:	f103 0201 	add.w	r2, r3, #1
     566:	687b      	ldr	r3, [r7, #4]
     568:	601a      	str	r2, [r3, #0]
	}
	else
	{ 
		(void)putchar(c);
	}
}
     56a:	f107 070c 	add.w	r7, r7, #12
     56e:	46bd      	mov	sp, r7
     570:	bc80      	pop	{r7}
     572:	4770      	bx	lr

00000574 <prints>:

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
     574:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     578:	b084      	sub	sp, #16
     57a:	af00      	add	r7, sp, #0
     57c:	60f8      	str	r0, [r7, #12]
     57e:	60b9      	str	r1, [r7, #8]
     580:	607a      	str	r2, [r7, #4]
     582:	603b      	str	r3, [r7, #0]
	register int pc = 0, padchar = ' ';
     584:	f04f 0400 	mov.w	r4, #0
     588:	f04f 0620 	mov.w	r6, #32

	if (width > 0) {
     58c:	687b      	ldr	r3, [r7, #4]
     58e:	2b00      	cmp	r3, #0
     590:	dd1e      	ble.n	5d0 <prints+0x5c>
		register int len = 0;
     592:	f04f 0500 	mov.w	r5, #0
		register const char *ptr;
		for (ptr = string; *ptr; ++ptr) ++len;
     596:	f8d7 8008 	ldr.w	r8, [r7, #8]
     59a:	e003      	b.n	5a4 <prints+0x30>
     59c:	f105 0501 	add.w	r5, r5, #1
     5a0:	f108 0801 	add.w	r8, r8, #1
     5a4:	f898 3000 	ldrb.w	r3, [r8]
     5a8:	2b00      	cmp	r3, #0
     5aa:	d1f7      	bne.n	59c <prints+0x28>
		if (len >= width) width = 0;
     5ac:	687b      	ldr	r3, [r7, #4]
     5ae:	429d      	cmp	r5, r3
     5b0:	db03      	blt.n	5ba <prints+0x46>
     5b2:	f04f 0300 	mov.w	r3, #0
     5b6:	607b      	str	r3, [r7, #4]
     5b8:	e003      	b.n	5c2 <prints+0x4e>
		else width -= len;
     5ba:	687b      	ldr	r3, [r7, #4]
     5bc:	ebc5 0303 	rsb	r3, r5, r3
     5c0:	607b      	str	r3, [r7, #4]
		if (pad & PAD_ZERO) padchar = '0';
     5c2:	683b      	ldr	r3, [r7, #0]
     5c4:	f003 0302 	and.w	r3, r3, #2
     5c8:	2b00      	cmp	r3, #0
     5ca:	d001      	beq.n	5d0 <prints+0x5c>
     5cc:	f04f 0630 	mov.w	r6, #48	; 0x30
	}
	if (!(pad & PAD_RIGHT)) {
     5d0:	683b      	ldr	r3, [r7, #0]
     5d2:	f003 0301 	and.w	r3, r3, #1
     5d6:	2b00      	cmp	r3, #0
     5d8:	d11b      	bne.n	612 <prints+0x9e>
		for ( ; width > 0; --width) {
     5da:	e009      	b.n	5f0 <prints+0x7c>
			printchar (out, padchar);
     5dc:	68f8      	ldr	r0, [r7, #12]
     5de:	4631      	mov	r1, r6
     5e0:	f7ff ffb0 	bl	544 <printchar>
			++pc;
     5e4:	f104 0401 	add.w	r4, r4, #1
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
		for ( ; width > 0; --width) {
     5e8:	687b      	ldr	r3, [r7, #4]
     5ea:	f103 33ff 	add.w	r3, r3, #4294967295
     5ee:	607b      	str	r3, [r7, #4]
     5f0:	687b      	ldr	r3, [r7, #4]
     5f2:	2b00      	cmp	r3, #0
     5f4:	dcf2      	bgt.n	5dc <prints+0x68>
			printchar (out, padchar);
			++pc;
		}
	}
	for ( ; *string ; ++string) {
     5f6:	e00d      	b.n	614 <prints+0xa0>
		printchar (out, *string);
     5f8:	68bb      	ldr	r3, [r7, #8]
     5fa:	781b      	ldrb	r3, [r3, #0]
     5fc:	68f8      	ldr	r0, [r7, #12]
     5fe:	4619      	mov	r1, r3
     600:	f7ff ffa0 	bl	544 <printchar>
		++pc;
     604:	f104 0401 	add.w	r4, r4, #1
		for ( ; width > 0; --width) {
			printchar (out, padchar);
			++pc;
		}
	}
	for ( ; *string ; ++string) {
     608:	68bb      	ldr	r3, [r7, #8]
     60a:	f103 0301 	add.w	r3, r3, #1
     60e:	60bb      	str	r3, [r7, #8]
     610:	e000      	b.n	614 <prints+0xa0>
     612:	bf00      	nop
     614:	68bb      	ldr	r3, [r7, #8]
     616:	781b      	ldrb	r3, [r3, #0]
     618:	2b00      	cmp	r3, #0
     61a:	d1ed      	bne.n	5f8 <prints+0x84>
		printchar (out, *string);
		++pc;
	}
	for ( ; width > 0; --width) {
     61c:	e009      	b.n	632 <prints+0xbe>
		printchar (out, padchar);
     61e:	68f8      	ldr	r0, [r7, #12]
     620:	4631      	mov	r1, r6
     622:	f7ff ff8f 	bl	544 <printchar>
		++pc;
     626:	f104 0401 	add.w	r4, r4, #1
	}
	for ( ; *string ; ++string) {
		printchar (out, *string);
		++pc;
	}
	for ( ; width > 0; --width) {
     62a:	687b      	ldr	r3, [r7, #4]
     62c:	f103 33ff 	add.w	r3, r3, #4294967295
     630:	607b      	str	r3, [r7, #4]
     632:	687b      	ldr	r3, [r7, #4]
     634:	2b00      	cmp	r3, #0
     636:	dcf2      	bgt.n	61e <prints+0xaa>
		printchar (out, padchar);
		++pc;
	}

	return pc;
     638:	4623      	mov	r3, r4
}
     63a:	4618      	mov	r0, r3
     63c:	f107 0710 	add.w	r7, r7, #16
     640:	46bd      	mov	sp, r7
     642:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     646:	bf00      	nop

00000648 <printi>:

/* the following should be enough for 32 bit int */
#define PRINT_BUF_LEN 12

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
     648:	e92d 45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
     64c:	b089      	sub	sp, #36	; 0x24
     64e:	af00      	add	r7, sp, #0
     650:	60f8      	str	r0, [r7, #12]
     652:	60b9      	str	r1, [r7, #8]
     654:	607a      	str	r2, [r7, #4]
     656:	603b      	str	r3, [r7, #0]
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
     658:	f04f 0a00 	mov.w	sl, #0
     65c:	f04f 0800 	mov.w	r8, #0
	register unsigned int u = (unsigned int)i;
     660:	68bd      	ldr	r5, [r7, #8]

	if (i == 0) {
     662:	68bb      	ldr	r3, [r7, #8]
     664:	2b00      	cmp	r3, #0
     666:	d10f      	bne.n	688 <printi+0x40>
		print_buf[0] = '0';
     668:	f04f 0330 	mov.w	r3, #48	; 0x30
     66c:	753b      	strb	r3, [r7, #20]
		print_buf[1] = '\0';
     66e:	f04f 0300 	mov.w	r3, #0
     672:	757b      	strb	r3, [r7, #21]
		return prints (out, print_buf, width, pad);
     674:	f107 0314 	add.w	r3, r7, #20
     678:	68f8      	ldr	r0, [r7, #12]
     67a:	4619      	mov	r1, r3
     67c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
     67e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     680:	f7ff ff78 	bl	574 <prints>
     684:	4603      	mov	r3, r0
     686:	e054      	b.n	732 <printi+0xea>
	}

	if (sg && b == 10 && i < 0) {
     688:	683b      	ldr	r3, [r7, #0]
     68a:	2b00      	cmp	r3, #0
     68c:	d00b      	beq.n	6a6 <printi+0x5e>
     68e:	687b      	ldr	r3, [r7, #4]
     690:	2b0a      	cmp	r3, #10
     692:	d108      	bne.n	6a6 <printi+0x5e>
     694:	68bb      	ldr	r3, [r7, #8]
     696:	2b00      	cmp	r3, #0
     698:	da05      	bge.n	6a6 <printi+0x5e>
		neg = 1;
     69a:	f04f 0a01 	mov.w	sl, #1
		u = (unsigned int)-i;
     69e:	68bb      	ldr	r3, [r7, #8]
     6a0:	f1c3 0300 	rsb	r3, r3, #0
     6a4:	461d      	mov	r5, r3
	}

	s = print_buf + PRINT_BUF_LEN-1;
     6a6:	f107 0314 	add.w	r3, r7, #20
     6aa:	f103 040b 	add.w	r4, r3, #11
	*s = '\0';
     6ae:	f04f 0300 	mov.w	r3, #0
     6b2:	7023      	strb	r3, [r4, #0]

	while (u) {
     6b4:	e017      	b.n	6e6 <printi+0x9e>
		t = (unsigned int)u % b;
     6b6:	687b      	ldr	r3, [r7, #4]
     6b8:	fbb5 f2f3 	udiv	r2, r5, r3
     6bc:	fb03 f302 	mul.w	r3, r3, r2
     6c0:	ebc3 0305 	rsb	r3, r3, r5
     6c4:	461e      	mov	r6, r3
		if( t >= 10 )
     6c6:	2e09      	cmp	r6, #9
     6c8:	dd03      	ble.n	6d2 <printi+0x8a>
			t += letbase - '0' - 10;
     6ca:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     6cc:	f1a3 033a 	sub.w	r3, r3, #58	; 0x3a
     6d0:	441e      	add	r6, r3
		*--s = (char)(t + '0');
     6d2:	f104 34ff 	add.w	r4, r4, #4294967295
     6d6:	b2f3      	uxtb	r3, r6
     6d8:	f103 0330 	add.w	r3, r3, #48	; 0x30
     6dc:	b2db      	uxtb	r3, r3
     6de:	7023      	strb	r3, [r4, #0]
		u /= b;
     6e0:	687b      	ldr	r3, [r7, #4]
     6e2:	fbb5 f5f3 	udiv	r5, r5, r3
	}

	s = print_buf + PRINT_BUF_LEN-1;
	*s = '\0';

	while (u) {
     6e6:	2d00      	cmp	r5, #0
     6e8:	d1e5      	bne.n	6b6 <printi+0x6e>
			t += letbase - '0' - 10;
		*--s = (char)(t + '0');
		u /= b;
	}

	if (neg) {
     6ea:	f1ba 0f00 	cmp.w	sl, #0
     6ee:	d018      	beq.n	722 <printi+0xda>
		if( width && (pad & PAD_ZERO) ) {
     6f0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     6f2:	2b00      	cmp	r3, #0
     6f4:	d010      	beq.n	718 <printi+0xd0>
     6f6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     6f8:	f003 0302 	and.w	r3, r3, #2
     6fc:	2b00      	cmp	r3, #0
     6fe:	d00b      	beq.n	718 <printi+0xd0>
			printchar (out, '-');
     700:	68f8      	ldr	r0, [r7, #12]
     702:	f04f 012d 	mov.w	r1, #45	; 0x2d
     706:	f7ff ff1d 	bl	544 <printchar>
			++pc;
     70a:	f108 0801 	add.w	r8, r8, #1
			--width;
     70e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     710:	f103 33ff 	add.w	r3, r3, #4294967295
     714:	643b      	str	r3, [r7, #64]	; 0x40
		*--s = (char)(t + '0');
		u /= b;
	}

	if (neg) {
		if( width && (pad & PAD_ZERO) ) {
     716:	e004      	b.n	722 <printi+0xda>
			printchar (out, '-');
			++pc;
			--width;
		}
		else {
			*--s = '-';
     718:	f104 34ff 	add.w	r4, r4, #4294967295
     71c:	f04f 032d 	mov.w	r3, #45	; 0x2d
     720:	7023      	strb	r3, [r4, #0]
		}
	}

	return pc + prints (out, s, width, pad);
     722:	68f8      	ldr	r0, [r7, #12]
     724:	4621      	mov	r1, r4
     726:	6c3a      	ldr	r2, [r7, #64]	; 0x40
     728:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     72a:	f7ff ff23 	bl	574 <prints>
     72e:	4603      	mov	r3, r0
     730:	4443      	add	r3, r8
}
     732:	4618      	mov	r0, r3
     734:	f107 0724 	add.w	r7, r7, #36	; 0x24
     738:	46bd      	mov	sp, r7
     73a:	e8bd 85f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, pc}
     73e:	bf00      	nop

00000740 <print>:

static int print( char **out, const char *format, va_list args )
{
     740:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     744:	b08a      	sub	sp, #40	; 0x28
     746:	af04      	add	r7, sp, #16
     748:	60f8      	str	r0, [r7, #12]
     74a:	60b9      	str	r1, [r7, #8]
     74c:	607a      	str	r2, [r7, #4]
	register int width, pad;
	register int pc = 0;
     74e:	f04f 0400 	mov.w	r4, #0
	char scr[2];

	for (; *format != 0; ++format) {
     752:	e0ed      	b.n	930 <print+0x1f0>
		if (*format == '%') {
     754:	68bb      	ldr	r3, [r7, #8]
     756:	781b      	ldrb	r3, [r3, #0]
     758:	2b25      	cmp	r3, #37	; 0x25
     75a:	f040 80db 	bne.w	914 <print+0x1d4>
			++format;
     75e:	68bb      	ldr	r3, [r7, #8]
     760:	f103 0301 	add.w	r3, r3, #1
     764:	60bb      	str	r3, [r7, #8]
			width = pad = 0;
     766:	f04f 0600 	mov.w	r6, #0
     76a:	4635      	mov	r5, r6
			if (*format == '\0') break;
     76c:	68bb      	ldr	r3, [r7, #8]
     76e:	781b      	ldrb	r3, [r3, #0]
     770:	2b00      	cmp	r3, #0
     772:	f000 80e3 	beq.w	93c <print+0x1fc>
			if (*format == '%') goto out;
     776:	68bb      	ldr	r3, [r7, #8]
     778:	781b      	ldrb	r3, [r3, #0]
     77a:	2b25      	cmp	r3, #37	; 0x25
     77c:	f000 80c9 	beq.w	912 <print+0x1d2>
			if (*format == '-') {
     780:	68bb      	ldr	r3, [r7, #8]
     782:	781b      	ldrb	r3, [r3, #0]
     784:	2b2d      	cmp	r3, #45	; 0x2d
     786:	d10d      	bne.n	7a4 <print+0x64>
				++format;
     788:	68bb      	ldr	r3, [r7, #8]
     78a:	f103 0301 	add.w	r3, r3, #1
     78e:	60bb      	str	r3, [r7, #8]
				pad = PAD_RIGHT;
     790:	f04f 0601 	mov.w	r6, #1
			}
			while (*format == '0') {
     794:	e007      	b.n	7a6 <print+0x66>
				++format;
     796:	68bb      	ldr	r3, [r7, #8]
     798:	f103 0301 	add.w	r3, r3, #1
     79c:	60bb      	str	r3, [r7, #8]
				pad |= PAD_ZERO;
     79e:	f046 0602 	orr.w	r6, r6, #2
     7a2:	e000      	b.n	7a6 <print+0x66>
			if (*format == '%') goto out;
			if (*format == '-') {
				++format;
				pad = PAD_RIGHT;
			}
			while (*format == '0') {
     7a4:	bf00      	nop
     7a6:	68bb      	ldr	r3, [r7, #8]
     7a8:	781b      	ldrb	r3, [r3, #0]
     7aa:	2b30      	cmp	r3, #48	; 0x30
     7ac:	d0f3      	beq.n	796 <print+0x56>
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
     7ae:	e00f      	b.n	7d0 <print+0x90>
				width *= 10;
     7b0:	462b      	mov	r3, r5
     7b2:	ea4f 0383 	mov.w	r3, r3, lsl #2
     7b6:	442b      	add	r3, r5
     7b8:	ea4f 0343 	mov.w	r3, r3, lsl #1
     7bc:	461d      	mov	r5, r3
				width += *format - '0';
     7be:	68bb      	ldr	r3, [r7, #8]
     7c0:	781b      	ldrb	r3, [r3, #0]
     7c2:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
     7c6:	441d      	add	r5, r3
			}
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
     7c8:	68bb      	ldr	r3, [r7, #8]
     7ca:	f103 0301 	add.w	r3, r3, #1
     7ce:	60bb      	str	r3, [r7, #8]
     7d0:	68bb      	ldr	r3, [r7, #8]
     7d2:	781b      	ldrb	r3, [r3, #0]
     7d4:	2b2f      	cmp	r3, #47	; 0x2f
     7d6:	d903      	bls.n	7e0 <print+0xa0>
     7d8:	68bb      	ldr	r3, [r7, #8]
     7da:	781b      	ldrb	r3, [r3, #0]
     7dc:	2b39      	cmp	r3, #57	; 0x39
     7de:	d9e7      	bls.n	7b0 <print+0x70>
				width *= 10;
				width += *format - '0';
			}
			if( *format == 's' ) {
     7e0:	68bb      	ldr	r3, [r7, #8]
     7e2:	781b      	ldrb	r3, [r3, #0]
     7e4:	2b73      	cmp	r3, #115	; 0x73
     7e6:	d117      	bne.n	818 <print+0xd8>
				register char *s = (char *)va_arg( args, int );
     7e8:	687b      	ldr	r3, [r7, #4]
     7ea:	f103 0204 	add.w	r2, r3, #4
     7ee:	607a      	str	r2, [r7, #4]
     7f0:	681b      	ldr	r3, [r3, #0]
     7f2:	4698      	mov	r8, r3
				pc += prints (out, s?s:"(null)", width, pad);
     7f4:	f1b8 0f00 	cmp.w	r8, #0
     7f8:	d001      	beq.n	7fe <print+0xbe>
     7fa:	4643      	mov	r3, r8
     7fc:	e003      	b.n	806 <print+0xc6>
     7fe:	f243 2358 	movw	r3, #12888	; 0x3258
     802:	f2c0 0300 	movt	r3, #0
     806:	68f8      	ldr	r0, [r7, #12]
     808:	4619      	mov	r1, r3
     80a:	462a      	mov	r2, r5
     80c:	4633      	mov	r3, r6
     80e:	f7ff feb1 	bl	574 <prints>
     812:	4603      	mov	r3, r0
     814:	441c      	add	r4, r3
				continue;
     816:	e087      	b.n	928 <print+0x1e8>
			}
			if( *format == 'd' ) {
     818:	68bb      	ldr	r3, [r7, #8]
     81a:	781b      	ldrb	r3, [r3, #0]
     81c:	2b64      	cmp	r3, #100	; 0x64
     81e:	d114      	bne.n	84a <print+0x10a>
				pc += printi (out, va_arg( args, int ), 10, 1, width, pad, 'a');
     820:	687b      	ldr	r3, [r7, #4]
     822:	f103 0204 	add.w	r2, r3, #4
     826:	607a      	str	r2, [r7, #4]
     828:	681b      	ldr	r3, [r3, #0]
     82a:	9500      	str	r5, [sp, #0]
     82c:	9601      	str	r6, [sp, #4]
     82e:	f04f 0261 	mov.w	r2, #97	; 0x61
     832:	9202      	str	r2, [sp, #8]
     834:	68f8      	ldr	r0, [r7, #12]
     836:	4619      	mov	r1, r3
     838:	f04f 020a 	mov.w	r2, #10
     83c:	f04f 0301 	mov.w	r3, #1
     840:	f7ff ff02 	bl	648 <printi>
     844:	4603      	mov	r3, r0
     846:	441c      	add	r4, r3
				continue;
     848:	e06e      	b.n	928 <print+0x1e8>
			}
			if( *format == 'x' ) {
     84a:	68bb      	ldr	r3, [r7, #8]
     84c:	781b      	ldrb	r3, [r3, #0]
     84e:	2b78      	cmp	r3, #120	; 0x78
     850:	d114      	bne.n	87c <print+0x13c>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'a');
     852:	687b      	ldr	r3, [r7, #4]
     854:	f103 0204 	add.w	r2, r3, #4
     858:	607a      	str	r2, [r7, #4]
     85a:	681b      	ldr	r3, [r3, #0]
     85c:	9500      	str	r5, [sp, #0]
     85e:	9601      	str	r6, [sp, #4]
     860:	f04f 0261 	mov.w	r2, #97	; 0x61
     864:	9202      	str	r2, [sp, #8]
     866:	68f8      	ldr	r0, [r7, #12]
     868:	4619      	mov	r1, r3
     86a:	f04f 0210 	mov.w	r2, #16
     86e:	f04f 0300 	mov.w	r3, #0
     872:	f7ff fee9 	bl	648 <printi>
     876:	4603      	mov	r3, r0
     878:	441c      	add	r4, r3
				continue;
     87a:	e055      	b.n	928 <print+0x1e8>
			}
			if( *format == 'X' ) {
     87c:	68bb      	ldr	r3, [r7, #8]
     87e:	781b      	ldrb	r3, [r3, #0]
     880:	2b58      	cmp	r3, #88	; 0x58
     882:	d114      	bne.n	8ae <print+0x16e>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'A');
     884:	687b      	ldr	r3, [r7, #4]
     886:	f103 0204 	add.w	r2, r3, #4
     88a:	607a      	str	r2, [r7, #4]
     88c:	681b      	ldr	r3, [r3, #0]
     88e:	9500      	str	r5, [sp, #0]
     890:	9601      	str	r6, [sp, #4]
     892:	f04f 0241 	mov.w	r2, #65	; 0x41
     896:	9202      	str	r2, [sp, #8]
     898:	68f8      	ldr	r0, [r7, #12]
     89a:	4619      	mov	r1, r3
     89c:	f04f 0210 	mov.w	r2, #16
     8a0:	f04f 0300 	mov.w	r3, #0
     8a4:	f7ff fed0 	bl	648 <printi>
     8a8:	4603      	mov	r3, r0
     8aa:	441c      	add	r4, r3
				continue;
     8ac:	e03c      	b.n	928 <print+0x1e8>
			}
			if( *format == 'u' ) {
     8ae:	68bb      	ldr	r3, [r7, #8]
     8b0:	781b      	ldrb	r3, [r3, #0]
     8b2:	2b75      	cmp	r3, #117	; 0x75
     8b4:	d114      	bne.n	8e0 <print+0x1a0>
				pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
     8b6:	687b      	ldr	r3, [r7, #4]
     8b8:	f103 0204 	add.w	r2, r3, #4
     8bc:	607a      	str	r2, [r7, #4]
     8be:	681b      	ldr	r3, [r3, #0]
     8c0:	9500      	str	r5, [sp, #0]
     8c2:	9601      	str	r6, [sp, #4]
     8c4:	f04f 0261 	mov.w	r2, #97	; 0x61
     8c8:	9202      	str	r2, [sp, #8]
     8ca:	68f8      	ldr	r0, [r7, #12]
     8cc:	4619      	mov	r1, r3
     8ce:	f04f 020a 	mov.w	r2, #10
     8d2:	f04f 0300 	mov.w	r3, #0
     8d6:	f7ff feb7 	bl	648 <printi>
     8da:	4603      	mov	r3, r0
     8dc:	441c      	add	r4, r3
				continue;
     8de:	e023      	b.n	928 <print+0x1e8>
			}
			if( *format == 'c' ) {
     8e0:	68bb      	ldr	r3, [r7, #8]
     8e2:	781b      	ldrb	r3, [r3, #0]
     8e4:	2b63      	cmp	r3, #99	; 0x63
     8e6:	d11e      	bne.n	926 <print+0x1e6>
				/* char are converted to int then pushed on the stack */
				scr[0] = (char)va_arg( args, int );
     8e8:	687b      	ldr	r3, [r7, #4]
     8ea:	f103 0204 	add.w	r2, r3, #4
     8ee:	607a      	str	r2, [r7, #4]
     8f0:	681b      	ldr	r3, [r3, #0]
     8f2:	b2db      	uxtb	r3, r3
     8f4:	753b      	strb	r3, [r7, #20]
				scr[1] = '\0';
     8f6:	f04f 0300 	mov.w	r3, #0
     8fa:	757b      	strb	r3, [r7, #21]
				pc += prints (out, scr, width, pad);
     8fc:	f107 0314 	add.w	r3, r7, #20
     900:	68f8      	ldr	r0, [r7, #12]
     902:	4619      	mov	r1, r3
     904:	462a      	mov	r2, r5
     906:	4633      	mov	r3, r6
     908:	f7ff fe34 	bl	574 <prints>
     90c:	4603      	mov	r3, r0
     90e:	441c      	add	r4, r3
				continue;
     910:	e00a      	b.n	928 <print+0x1e8>
	for (; *format != 0; ++format) {
		if (*format == '%') {
			++format;
			width = pad = 0;
			if (*format == '\0') break;
			if (*format == '%') goto out;
     912:	bf00      	nop
				continue;
			}
		}
		else {
		out:
			printchar (out, *format);
     914:	68bb      	ldr	r3, [r7, #8]
     916:	781b      	ldrb	r3, [r3, #0]
     918:	68f8      	ldr	r0, [r7, #12]
     91a:	4619      	mov	r1, r3
     91c:	f7ff fe12 	bl	544 <printchar>
			++pc;
     920:	f104 0401 	add.w	r4, r4, #1
     924:	e000      	b.n	928 <print+0x1e8>
			if( *format == 'c' ) {
				/* char are converted to int then pushed on the stack */
				scr[0] = (char)va_arg( args, int );
				scr[1] = '\0';
				pc += prints (out, scr, width, pad);
				continue;
     926:	bf00      	nop
{
	register int width, pad;
	register int pc = 0;
	char scr[2];

	for (; *format != 0; ++format) {
     928:	68bb      	ldr	r3, [r7, #8]
     92a:	f103 0301 	add.w	r3, r3, #1
     92e:	60bb      	str	r3, [r7, #8]
     930:	68bb      	ldr	r3, [r7, #8]
     932:	781b      	ldrb	r3, [r3, #0]
     934:	2b00      	cmp	r3, #0
     936:	f47f af0d 	bne.w	754 <print+0x14>
     93a:	e000      	b.n	93e <print+0x1fe>
		if (*format == '%') {
			++format;
			width = pad = 0;
			if (*format == '\0') break;
     93c:	bf00      	nop
		out:
			printchar (out, *format);
			++pc;
		}
	}
	if (out) **out = '\0';
     93e:	68fb      	ldr	r3, [r7, #12]
     940:	2b00      	cmp	r3, #0
     942:	d004      	beq.n	94e <print+0x20e>
     944:	68fb      	ldr	r3, [r7, #12]
     946:	681b      	ldr	r3, [r3, #0]
     948:	f04f 0200 	mov.w	r2, #0
     94c:	701a      	strb	r2, [r3, #0]
	va_end( args );
	return pc;
     94e:	4623      	mov	r3, r4
}
     950:	4618      	mov	r0, r3
     952:	f107 0718 	add.w	r7, r7, #24
     956:	46bd      	mov	sp, r7
     958:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000095c <printf>:

int printf(const char *format, ...)
{
     95c:	b40f      	push	{r0, r1, r2, r3}
     95e:	b580      	push	{r7, lr}
     960:	b082      	sub	sp, #8
     962:	af00      	add	r7, sp, #0
        va_list args;
        
        va_start( args, format );
     964:	f107 0314 	add.w	r3, r7, #20
     968:	607b      	str	r3, [r7, #4]
        return print( 0, format, args );
     96a:	f04f 0000 	mov.w	r0, #0
     96e:	6939      	ldr	r1, [r7, #16]
     970:	687a      	ldr	r2, [r7, #4]
     972:	f7ff fee5 	bl	740 <print>
     976:	4603      	mov	r3, r0
}
     978:	4618      	mov	r0, r3
     97a:	f107 0708 	add.w	r7, r7, #8
     97e:	46bd      	mov	sp, r7
     980:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
     984:	b004      	add	sp, #16
     986:	4770      	bx	lr

00000988 <sprintf>:

int sprintf(char *out, const char *format, ...)
{
     988:	b40e      	push	{r1, r2, r3}
     98a:	b580      	push	{r7, lr}
     98c:	b085      	sub	sp, #20
     98e:	af00      	add	r7, sp, #0
     990:	6078      	str	r0, [r7, #4]
        va_list args;
        
        va_start( args, format );
     992:	f107 0320 	add.w	r3, r7, #32
     996:	60fb      	str	r3, [r7, #12]
        return print( &out, format, args );
     998:	f107 0304 	add.w	r3, r7, #4
     99c:	4618      	mov	r0, r3
     99e:	69f9      	ldr	r1, [r7, #28]
     9a0:	68fa      	ldr	r2, [r7, #12]
     9a2:	f7ff fecd 	bl	740 <print>
     9a6:	4603      	mov	r3, r0
}
     9a8:	4618      	mov	r0, r3
     9aa:	f107 0714 	add.w	r7, r7, #20
     9ae:	46bd      	mov	sp, r7
     9b0:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
     9b4:	b003      	add	sp, #12
     9b6:	4770      	bx	lr

000009b8 <snprintf>:


int snprintf( char *buf, unsigned int count, const char *format, ... )
{
     9b8:	b40c      	push	{r2, r3}
     9ba:	b580      	push	{r7, lr}
     9bc:	b084      	sub	sp, #16
     9be:	af00      	add	r7, sp, #0
     9c0:	6078      	str	r0, [r7, #4]
     9c2:	6039      	str	r1, [r7, #0]
        va_list args;
        
        ( void ) count;
        
        va_start( args, format );
     9c4:	f107 031c 	add.w	r3, r7, #28
     9c8:	60fb      	str	r3, [r7, #12]
        return print( &buf, format, args );
     9ca:	f107 0304 	add.w	r3, r7, #4
     9ce:	4618      	mov	r0, r3
     9d0:	69b9      	ldr	r1, [r7, #24]
     9d2:	68fa      	ldr	r2, [r7, #12]
     9d4:	f7ff feb4 	bl	740 <print>
     9d8:	4603      	mov	r3, r0
}
     9da:	4618      	mov	r0, r3
     9dc:	f107 0710 	add.w	r7, r7, #16
     9e0:	46bd      	mov	sp, r7
     9e2:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
     9e6:	b002      	add	sp, #8
     9e8:	4770      	bx	lr
     9ea:	bf00      	nop

000009ec <write>:
#endif


/* To keep linker happy. */
int	write( int i, char* c, int n)
{
     9ec:	b480      	push	{r7}
     9ee:	b085      	sub	sp, #20
     9f0:	af00      	add	r7, sp, #0
     9f2:	60f8      	str	r0, [r7, #12]
     9f4:	60b9      	str	r1, [r7, #8]
     9f6:	607a      	str	r2, [r7, #4]
	(void)i;
	(void)n;
	(void)c;
	return 0;
     9f8:	f04f 0300 	mov.w	r3, #0
}
     9fc:	4618      	mov	r0, r3
     9fe:	f107 0714 	add.w	r7, r7, #20
     a02:	46bd      	mov	sp, r7
     a04:	bc80      	pop	{r7}
     a06:	4770      	bx	lr

00000a08 <_read_r>:

#include <stdlib.h>
#include <sys/stat.h>

int _read_r (struct _reent *r, int file, char * ptr, int len)
{
     a08:	b480      	push	{r7}
     a0a:	b085      	sub	sp, #20
     a0c:	af00      	add	r7, sp, #0
     a0e:	60f8      	str	r0, [r7, #12]
     a10:	60b9      	str	r1, [r7, #8]
     a12:	607a      	str	r2, [r7, #4]
     a14:	603b      	str	r3, [r7, #0]
	( void ) r;
	( void ) file;
	( void ) ptr;
	( void ) len;
	return -1;
     a16:	f04f 33ff 	mov.w	r3, #4294967295
}
     a1a:	4618      	mov	r0, r3
     a1c:	f107 0714 	add.w	r7, r7, #20
     a20:	46bd      	mov	sp, r7
     a22:	bc80      	pop	{r7}
     a24:	4770      	bx	lr
     a26:	bf00      	nop

00000a28 <_lseek_r>:

/***************************************************************************/

int _lseek_r (struct _reent *r, int file, int ptr, int dir)
{
     a28:	b480      	push	{r7}
     a2a:	b085      	sub	sp, #20
     a2c:	af00      	add	r7, sp, #0
     a2e:	60f8      	str	r0, [r7, #12]
     a30:	60b9      	str	r1, [r7, #8]
     a32:	607a      	str	r2, [r7, #4]
     a34:	603b      	str	r3, [r7, #0]
	( void ) r;
	( void ) file;
	( void ) ptr;
	( void ) dir;
	
	return 0;
     a36:	f04f 0300 	mov.w	r3, #0
}
     a3a:	4618      	mov	r0, r3
     a3c:	f107 0714 	add.w	r7, r7, #20
     a40:	46bd      	mov	sp, r7
     a42:	bc80      	pop	{r7}
     a44:	4770      	bx	lr
     a46:	bf00      	nop

00000a48 <_write_r>:

/***************************************************************************/

int _write_r (struct _reent *r, int file, char * ptr, int len)
{  
     a48:	b480      	push	{r7}
     a4a:	b085      	sub	sp, #20
     a4c:	af00      	add	r7, sp, #0
     a4e:	60f8      	str	r0, [r7, #12]
     a50:	60b9      	str	r1, [r7, #8]
     a52:	607a      	str	r2, [r7, #4]
     a54:	603b      	str	r3, [r7, #0]
	( void ) r;
	( void ) file;
	( void ) ptr;
	( void ) len;
	
	return 0;
     a56:	f04f 0300 	mov.w	r3, #0
}
     a5a:	4618      	mov	r0, r3
     a5c:	f107 0714 	add.w	r7, r7, #20
     a60:	46bd      	mov	sp, r7
     a62:	bc80      	pop	{r7}
     a64:	4770      	bx	lr
     a66:	bf00      	nop

00000a68 <_close_r>:

/***************************************************************************/

int _close_r (struct _reent *r, int file)
{
     a68:	b480      	push	{r7}
     a6a:	b083      	sub	sp, #12
     a6c:	af00      	add	r7, sp, #0
     a6e:	6078      	str	r0, [r7, #4]
     a70:	6039      	str	r1, [r7, #0]
	( void ) r;
	( void ) file;

	return 0;
     a72:	f04f 0300 	mov.w	r3, #0
}
     a76:	4618      	mov	r0, r3
     a78:	f107 070c 	add.w	r7, r7, #12
     a7c:	46bd      	mov	sp, r7
     a7e:	bc80      	pop	{r7}
     a80:	4770      	bx	lr
     a82:	bf00      	nop

00000a84 <_sbrk_r>:

/***************************************************************************/

caddr_t _sbrk_r (struct _reent *r, int incr)
{
     a84:	b480      	push	{r7}
     a86:	b083      	sub	sp, #12
     a88:	af00      	add	r7, sp, #0
     a8a:	6078      	str	r0, [r7, #4]
     a8c:	6039      	str	r1, [r7, #0]
	( void ) r;
	( void ) incr;
	
	return 0;
     a8e:	f04f 0300 	mov.w	r3, #0
}
     a92:	4618      	mov	r0, r3
     a94:	f107 070c 	add.w	r7, r7, #12
     a98:	46bd      	mov	sp, r7
     a9a:	bc80      	pop	{r7}
     a9c:	4770      	bx	lr
     a9e:	bf00      	nop

00000aa0 <_fstat_r>:

/***************************************************************************/

int _fstat_r (struct _reent *r, int file, struct stat * st)
{
     aa0:	b480      	push	{r7}
     aa2:	b085      	sub	sp, #20
     aa4:	af00      	add	r7, sp, #0
     aa6:	60f8      	str	r0, [r7, #12]
     aa8:	60b9      	str	r1, [r7, #8]
     aaa:	607a      	str	r2, [r7, #4]
	( void ) r;
	( void ) file;
	( void ) st;
	
	return 0;
     aac:	f04f 0300 	mov.w	r3, #0
}
     ab0:	4618      	mov	r0, r3
     ab2:	f107 0714 	add.w	r7, r7, #20
     ab6:	46bd      	mov	sp, r7
     ab8:	bc80      	pop	{r7}
     aba:	4770      	bx	lr

00000abc <_isatty_r>:

/***************************************************************************/

int _isatty_r(struct _reent *r, int fd)
{
     abc:	b480      	push	{r7}
     abe:	b083      	sub	sp, #12
     ac0:	af00      	add	r7, sp, #0
     ac2:	6078      	str	r0, [r7, #4]
     ac4:	6039      	str	r1, [r7, #0]
	( void ) r;
	( void ) fd;
	
	return 0;
     ac6:	f04f 0300 	mov.w	r3, #0
}
     aca:	4618      	mov	r0, r3
     acc:	f107 070c 	add.w	r7, r7, #12
     ad0:	46bd      	mov	sp, r7
     ad2:	bc80      	pop	{r7}
     ad4:	4770      	bx	lr
     ad6:	bf00      	nop

00000ad8 <Reset_Handler>:

extern int main(void);

/* Reset Handler */
void Reset_Handler(void)
{
     ad8:	b580      	push	{r7, lr}
     ada:	b082      	sub	sp, #8
     adc:	af00      	add	r7, sp, #0
    unsigned long *src, *dest;

	// Copy the data segment initializers from flash to SRAM
	src = &_etext;
     ade:	f243 238c 	movw	r3, #12940	; 0x328c
     ae2:	f2c0 0300 	movt	r3, #0
     ae6:	603b      	str	r3, [r7, #0]
	for(dest = &_data; dest < &_edata; )
     ae8:	f240 0300 	movw	r3, #0
     aec:	f2c1 0300 	movt	r3, #4096	; 0x1000
     af0:	607b      	str	r3, [r7, #4]
     af2:	e00b      	b.n	b0c <Reset_Handler+0x34>
	{
		*dest++ = *src++;
     af4:	683b      	ldr	r3, [r7, #0]
     af6:	681a      	ldr	r2, [r3, #0]
     af8:	687b      	ldr	r3, [r7, #4]
     afa:	601a      	str	r2, [r3, #0]
     afc:	687b      	ldr	r3, [r7, #4]
     afe:	f103 0304 	add.w	r3, r3, #4
     b02:	607b      	str	r3, [r7, #4]
     b04:	683b      	ldr	r3, [r7, #0]
     b06:	f103 0304 	add.w	r3, r3, #4
     b0a:	603b      	str	r3, [r7, #0]
{
    unsigned long *src, *dest;

	// Copy the data segment initializers from flash to SRAM
	src = &_etext;
	for(dest = &_data; dest < &_edata; )
     b0c:	687a      	ldr	r2, [r7, #4]
     b0e:	f240 030c 	movw	r3, #12
     b12:	f2c1 0300 	movt	r3, #4096	; 0x1000
     b16:	429a      	cmp	r2, r3
     b18:	d3ec      	bcc.n	af4 <Reset_Handler+0x1c>
	{
		*dest++ = *src++;
	}

	// Initialize the .bss segment of memory to zeros
	src = &_bss;
     b1a:	f240 0318 	movw	r3, #24
     b1e:	f2c1 0300 	movt	r3, #4096	; 0x1000
     b22:	603b      	str	r3, [r7, #0]
	while (src < &_ebss)
     b24:	e007      	b.n	b36 <Reset_Handler+0x5e>
	{
		*src++ = 0;
     b26:	683b      	ldr	r3, [r7, #0]
     b28:	f04f 0200 	mov.w	r2, #0
     b2c:	601a      	str	r2, [r3, #0]
     b2e:	683b      	ldr	r3, [r7, #0]
     b30:	f103 0304 	add.w	r3, r3, #4
     b34:	603b      	str	r3, [r7, #0]
		*dest++ = *src++;
	}

	// Initialize the .bss segment of memory to zeros
	src = &_bss;
	while (src < &_ebss)
     b36:	683a      	ldr	r2, [r7, #0]
     b38:	f644 538c 	movw	r3, #19852	; 0x4d8c
     b3c:	f2c1 0300 	movt	r3, #4096	; 0x1000
     b40:	429a      	cmp	r2, r3
     b42:	d3f0      	bcc.n	b26 <Reset_Handler+0x4e>
	{
		*src++ = 0;
	}

	main();
     b44:	f7ff fb22 	bl	18c <main>

	// In case main() fails, have something to breakpoint
	while (1) {;}
     b48:	e7fe      	b.n	b48 <Reset_Handler+0x70>
     b4a:	bf00      	nop

00000b4c <ADC_IRQHandler>:
}


/* Default interrupt handler */
static void Default_Handler(void) { while(1) {;} }
     b4c:	b480      	push	{r7}
     b4e:	af00      	add	r7, sp, #0
     b50:	e7fe      	b.n	b50 <ADC_IRQHandler+0x4>
     b52:	bf00      	nop

00000b54 <SystemCoreClockUpdate>:

/*----------------------------------------------------------------------------
  Clock functions
 *----------------------------------------------------------------------------*/
void SystemCoreClockUpdate (void)            /* Get Core Clock Frequency      */
{
     b54:	b480      	push	{r7}
     b56:	af00      	add	r7, sp, #0
  /* Determine clock frequency according to clock register values             */
  if (((LPC_SC->PLL0STAT >> 24) & 3) == 3) { /* If PLL0 enabled and connected */
     b58:	f24c 0300 	movw	r3, #49152	; 0xc000
     b5c:	f2c4 030f 	movt	r3, #16399	; 0x400f
     b60:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
     b64:	ea4f 6313 	mov.w	r3, r3, lsr #24
     b68:	f003 0303 	and.w	r3, r3, #3
     b6c:	2b03      	cmp	r3, #3
     b6e:	f040 80ac 	bne.w	cca <SystemCoreClockUpdate+0x176>
    switch (LPC_SC->CLKSRCSEL & 0x03) {
     b72:	f24c 0300 	movw	r3, #49152	; 0xc000
     b76:	f2c4 030f 	movt	r3, #16399	; 0x400f
     b7a:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
     b7e:	f003 0303 	and.w	r3, r3, #3
     b82:	2b03      	cmp	r3, #3
     b84:	f200 80f6 	bhi.w	d74 <SystemCoreClockUpdate+0x220>
     b88:	a201      	add	r2, pc, #4	; (adr r2, b90 <SystemCoreClockUpdate+0x3c>)
     b8a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     b8e:	bf00      	nop
     b90:	00000ba1 	.word	0x00000ba1
     b94:	00000c05 	.word	0x00000c05
     b98:	00000c6b 	.word	0x00000c6b
     b9c:	00000ba1 	.word	0x00000ba1
      case 0:                                /* Int. RC oscillator => PLL0    */
      case 3:                                /* Reserved, default to Int. RC  */
        SystemCoreClock = (IRC_OSC * 
                          ((2 * ((LPC_SC->PLL0STAT & 0x7FFF) + 1)))  /
     ba0:	f24c 0300 	movw	r3, #49152	; 0xc000
     ba4:	f2c4 030f 	movt	r3, #16399	; 0x400f
     ba8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
     bac:	ea4f 4343 	mov.w	r3, r3, lsl #17
     bb0:	ea4f 4353 	mov.w	r3, r3, lsr #17
     bb4:	f103 0201 	add.w	r2, r3, #1
     bb8:	f241 2300 	movw	r3, #4608	; 0x1200
     bbc:	f2c0 037a 	movt	r3, #122	; 0x7a
     bc0:	fb03 f202 	mul.w	r2, r3, r2
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
     bc4:	f24c 0300 	movw	r3, #49152	; 0xc000
     bc8:	f2c4 030f 	movt	r3, #16399	; 0x400f
     bcc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
     bd0:	ea4f 4313 	mov.w	r3, r3, lsr #16
     bd4:	f003 03ff 	and.w	r3, r3, #255	; 0xff
     bd8:	f103 0301 	add.w	r3, r3, #1
     bdc:	fbb2 f2f3 	udiv	r2, r2, r3
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
     be0:	f24c 0300 	movw	r3, #49152	; 0xc000
     be4:	f2c4 030f 	movt	r3, #16399	; 0x400f
     be8:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
     bec:	f003 03ff 	and.w	r3, r3, #255	; 0xff
     bf0:	f103 0301 	add.w	r3, r3, #1
  /* Determine clock frequency according to clock register values             */
  if (((LPC_SC->PLL0STAT >> 24) & 3) == 3) { /* If PLL0 enabled and connected */
    switch (LPC_SC->CLKSRCSEL & 0x03) {
      case 0:                                /* Int. RC oscillator => PLL0    */
      case 3:                                /* Reserved, default to Int. RC  */
        SystemCoreClock = (IRC_OSC * 
     bf4:	fbb2 f2f3 	udiv	r2, r2, r3
     bf8:	f240 0304 	movw	r3, #4
     bfc:	f2c1 0300 	movt	r3, #4096	; 0x1000
     c00:	601a      	str	r2, [r3, #0]
                          ((2 * ((LPC_SC->PLL0STAT & 0x7FFF) + 1)))  /
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
        break;
     c02:	e0b8      	b.n	d76 <SystemCoreClockUpdate+0x222>
      case 1:                                /* Main oscillator => PLL0       */
        SystemCoreClock = (OSC_CLK * 
                          ((2 * ((LPC_SC->PLL0STAT & 0x7FFF) + 1)))  /
     c04:	f24c 0300 	movw	r3, #49152	; 0xc000
     c08:	f2c4 030f 	movt	r3, #16399	; 0x400f
     c0c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
     c10:	ea4f 4343 	mov.w	r3, r3, lsl #17
     c14:	ea4f 4353 	mov.w	r3, r3, lsr #17
     c18:	f103 0201 	add.w	r2, r3, #1
     c1c:	f243 6300 	movw	r3, #13824	; 0x3600
     c20:	f2c0 136e 	movt	r3, #366	; 0x16e
     c24:	fb03 f202 	mul.w	r2, r3, r2
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
     c28:	f24c 0300 	movw	r3, #49152	; 0xc000
     c2c:	f2c4 030f 	movt	r3, #16399	; 0x400f
     c30:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
     c34:	ea4f 4313 	mov.w	r3, r3, lsr #16
     c38:	f003 03ff 	and.w	r3, r3, #255	; 0xff
     c3c:	f103 0301 	add.w	r3, r3, #1
     c40:	fbb2 f2f3 	udiv	r2, r2, r3
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
     c44:	f24c 0300 	movw	r3, #49152	; 0xc000
     c48:	f2c4 030f 	movt	r3, #16399	; 0x400f
     c4c:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
     c50:	f003 03ff 	and.w	r3, r3, #255	; 0xff
     c54:	f103 0301 	add.w	r3, r3, #1
                          ((2 * ((LPC_SC->PLL0STAT & 0x7FFF) + 1)))  /
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
        break;
      case 1:                                /* Main oscillator => PLL0       */
        SystemCoreClock = (OSC_CLK * 
     c58:	fbb2 f2f3 	udiv	r2, r2, r3
     c5c:	f240 0304 	movw	r3, #4
     c60:	f2c1 0300 	movt	r3, #4096	; 0x1000
     c64:	601a      	str	r2, [r3, #0]
                          ((2 * ((LPC_SC->PLL0STAT & 0x7FFF) + 1)))  /
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
        break;
     c66:	bf00      	nop
     c68:	e085      	b.n	d76 <SystemCoreClockUpdate+0x222>
      case 2:                                /* RTC oscillator => PLL0        */
        SystemCoreClock = (RTC_CLK * 
                          ((2 * ((LPC_SC->PLL0STAT & 0x7FFF) + 1)))  /
     c6a:	f24c 0300 	movw	r3, #49152	; 0xc000
     c6e:	f2c4 030f 	movt	r3, #16399	; 0x400f
     c72:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
     c76:	ea4f 4343 	mov.w	r3, r3, lsl #17
     c7a:	ea4f 4353 	mov.w	r3, r3, lsr #17
     c7e:	f103 0301 	add.w	r3, r3, #1
     c82:	f44f 427a 	mov.w	r2, #64000	; 0xfa00
     c86:	fb02 f203 	mul.w	r2, r2, r3
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
     c8a:	f24c 0300 	movw	r3, #49152	; 0xc000
     c8e:	f2c4 030f 	movt	r3, #16399	; 0x400f
     c92:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
     c96:	ea4f 4313 	mov.w	r3, r3, lsr #16
     c9a:	f003 03ff 	and.w	r3, r3, #255	; 0xff
     c9e:	f103 0301 	add.w	r3, r3, #1
     ca2:	fbb2 f2f3 	udiv	r2, r2, r3
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
     ca6:	f24c 0300 	movw	r3, #49152	; 0xc000
     caa:	f2c4 030f 	movt	r3, #16399	; 0x400f
     cae:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
     cb2:	f003 03ff 	and.w	r3, r3, #255	; 0xff
     cb6:	f103 0301 	add.w	r3, r3, #1
                          ((2 * ((LPC_SC->PLL0STAT & 0x7FFF) + 1)))  /
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
        break;
      case 2:                                /* RTC oscillator => PLL0        */
        SystemCoreClock = (RTC_CLK * 
     cba:	fbb2 f2f3 	udiv	r2, r2, r3
     cbe:	f240 0304 	movw	r3, #4
     cc2:	f2c1 0300 	movt	r3, #4096	; 0x1000
     cc6:	601a      	str	r2, [r3, #0]
     cc8:	e055      	b.n	d76 <SystemCoreClockUpdate+0x222>
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
        break;
    }
  } else {
    switch (LPC_SC->CLKSRCSEL & 0x03) {
     cca:	f24c 0300 	movw	r3, #49152	; 0xc000
     cce:	f2c4 030f 	movt	r3, #16399	; 0x400f
     cd2:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
     cd6:	f003 0303 	and.w	r3, r3, #3
     cda:	2b03      	cmp	r3, #3
     cdc:	d84b      	bhi.n	d76 <SystemCoreClockUpdate+0x222>
     cde:	a201      	add	r2, pc, #4	; (adr r2, ce4 <SystemCoreClockUpdate+0x190>)
     ce0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     ce4:	00000cf5 	.word	0x00000cf5
     ce8:	00000d21 	.word	0x00000d21
     cec:	00000d4d 	.word	0x00000d4d
     cf0:	00000cf5 	.word	0x00000cf5
      case 0:                                /* Int. RC oscillator => PLL0    */
      case 3:                                /* Reserved, default to Int. RC  */
        SystemCoreClock = IRC_OSC / ((LPC_SC->CCLKCFG & 0xFF)+ 1);
     cf4:	f24c 0300 	movw	r3, #49152	; 0xc000
     cf8:	f2c4 030f 	movt	r3, #16399	; 0x400f
     cfc:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
     d00:	f003 03ff 	and.w	r3, r3, #255	; 0xff
     d04:	f103 0201 	add.w	r2, r3, #1
     d08:	f640 1300 	movw	r3, #2304	; 0x900
     d0c:	f2c0 033d 	movt	r3, #61	; 0x3d
     d10:	fbb3 f2f2 	udiv	r2, r3, r2
     d14:	f240 0304 	movw	r3, #4
     d18:	f2c1 0300 	movt	r3, #4096	; 0x1000
     d1c:	601a      	str	r2, [r3, #0]
        break;
     d1e:	e02a      	b.n	d76 <SystemCoreClockUpdate+0x222>
      case 1:                                /* Main oscillator => PLL0       */
        SystemCoreClock = OSC_CLK / ((LPC_SC->CCLKCFG & 0xFF)+ 1);
     d20:	f24c 0300 	movw	r3, #49152	; 0xc000
     d24:	f2c4 030f 	movt	r3, #16399	; 0x400f
     d28:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
     d2c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
     d30:	f103 0201 	add.w	r2, r3, #1
     d34:	f641 3300 	movw	r3, #6912	; 0x1b00
     d38:	f2c0 03b7 	movt	r3, #183	; 0xb7
     d3c:	fbb3 f2f2 	udiv	r2, r3, r2
     d40:	f240 0304 	movw	r3, #4
     d44:	f2c1 0300 	movt	r3, #4096	; 0x1000
     d48:	601a      	str	r2, [r3, #0]
        break;
     d4a:	e014      	b.n	d76 <SystemCoreClockUpdate+0x222>
      case 2:                                /* RTC oscillator => PLL0        */
        SystemCoreClock = RTC_CLK / ((LPC_SC->CCLKCFG & 0xFF)+ 1);
     d4c:	f24c 0300 	movw	r3, #49152	; 0xc000
     d50:	f2c4 030f 	movt	r3, #16399	; 0x400f
     d54:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
     d58:	f003 03ff 	and.w	r3, r3, #255	; 0xff
     d5c:	f103 0301 	add.w	r3, r3, #1
     d60:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
     d64:	fbb2 f2f3 	udiv	r2, r2, r3
     d68:	f240 0304 	movw	r3, #4
     d6c:	f2c1 0300 	movt	r3, #4096	; 0x1000
     d70:	601a      	str	r2, [r3, #0]
     d72:	e000      	b.n	d76 <SystemCoreClockUpdate+0x222>
                          ((2 * ((LPC_SC->PLL0STAT & 0x7FFF) + 1)))  /
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
        break;
      case 2:                                /* RTC oscillator => PLL0        */
        SystemCoreClock = (RTC_CLK * 
     d74:	bf00      	nop
        SystemCoreClock = RTC_CLK / ((LPC_SC->CCLKCFG & 0xFF)+ 1);
        break;
    }
  }

}
     d76:	46bd      	mov	sp, r7
     d78:	bc80      	pop	{r7}
     d7a:	4770      	bx	lr

00000d7c <SystemInit>:
 *
 * @brief  Setup the microcontroller system.
 *         Initialize the System.
 */
void SystemInit (void)
{
     d7c:	b480      	push	{r7}
     d7e:	af00      	add	r7, sp, #0
#if (CLOCK_SETUP)                       /* Clock Setup                        */
  LPC_SC->SCS       = SCS_Val;
     d80:	f24c 0300 	movw	r3, #49152	; 0xc000
     d84:	f2c4 030f 	movt	r3, #16399	; 0x400f
     d88:	f04f 0220 	mov.w	r2, #32
     d8c:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
  if (SCS_Val & (1 << 5)) {             /* If Main Oscillator is enabled      */
    while ((LPC_SC->SCS & (1<<6)) == 0);/* Wait for Oscillator to be ready    */
     d90:	f24c 0300 	movw	r3, #49152	; 0xc000
     d94:	f2c4 030f 	movt	r3, #16399	; 0x400f
     d98:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
     d9c:	f003 0340 	and.w	r3, r3, #64	; 0x40
     da0:	2b00      	cmp	r3, #0
     da2:	d0f5      	beq.n	d90 <SystemInit+0x14>
  }

  LPC_SC->CCLKCFG   = CCLKCFG_Val;      /* Setup Clock Divider                */
     da4:	f24c 0300 	movw	r3, #49152	; 0xc000
     da8:	f2c4 030f 	movt	r3, #16399	; 0x400f
     dac:	f04f 0203 	mov.w	r2, #3
     db0:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104

#if (PLL0_SETUP)
  LPC_SC->CLKSRCSEL = CLKSRCSEL_Val;    /* Select Clock Source for PLL0       */
     db4:	f24c 0300 	movw	r3, #49152	; 0xc000
     db8:	f2c4 030f 	movt	r3, #16399	; 0x400f
     dbc:	f04f 0201 	mov.w	r2, #1
     dc0:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c

  LPC_SC->PLL0CFG   = PLL0CFG_Val;      /* configure PLL0                     */
     dc4:	f24c 0300 	movw	r3, #49152	; 0xc000
     dc8:	f2c4 030f 	movt	r3, #16399	; 0x400f
     dcc:	f240 0263 	movw	r2, #99	; 0x63
     dd0:	f2c0 0205 	movt	r2, #5
     dd4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  LPC_SC->PLL0FEED  = 0xAA;
     dd8:	f24c 0300 	movw	r3, #49152	; 0xc000
     ddc:	f2c4 030f 	movt	r3, #16399	; 0x400f
     de0:	f04f 02aa 	mov.w	r2, #170	; 0xaa
     de4:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  LPC_SC->PLL0FEED  = 0x55;
     de8:	f24c 0300 	movw	r3, #49152	; 0xc000
     dec:	f2c4 030f 	movt	r3, #16399	; 0x400f
     df0:	f04f 0255 	mov.w	r2, #85	; 0x55
     df4:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

  LPC_SC->PLL0CON   = 0x01;             /* PLL0 Enable                        */
     df8:	f24c 0300 	movw	r3, #49152	; 0xc000
     dfc:	f2c4 030f 	movt	r3, #16399	; 0x400f
     e00:	f04f 0201 	mov.w	r2, #1
     e04:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  LPC_SC->PLL0FEED  = 0xAA;
     e08:	f24c 0300 	movw	r3, #49152	; 0xc000
     e0c:	f2c4 030f 	movt	r3, #16399	; 0x400f
     e10:	f04f 02aa 	mov.w	r2, #170	; 0xaa
     e14:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  LPC_SC->PLL0FEED  = 0x55;
     e18:	f24c 0300 	movw	r3, #49152	; 0xc000
     e1c:	f2c4 030f 	movt	r3, #16399	; 0x400f
     e20:	f04f 0255 	mov.w	r2, #85	; 0x55
     e24:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  while (!(LPC_SC->PLL0STAT & (1<<26)));/* Wait for PLOCK0                    */
     e28:	f24c 0300 	movw	r3, #49152	; 0xc000
     e2c:	f2c4 030f 	movt	r3, #16399	; 0x400f
     e30:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
     e34:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
     e38:	2b00      	cmp	r3, #0
     e3a:	d0f5      	beq.n	e28 <SystemInit+0xac>

  LPC_SC->PLL0CON   = 0x03;             /* PLL0 Enable & Connect              */
     e3c:	f24c 0300 	movw	r3, #49152	; 0xc000
     e40:	f2c4 030f 	movt	r3, #16399	; 0x400f
     e44:	f04f 0203 	mov.w	r2, #3
     e48:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  LPC_SC->PLL0FEED  = 0xAA;
     e4c:	f24c 0300 	movw	r3, #49152	; 0xc000
     e50:	f2c4 030f 	movt	r3, #16399	; 0x400f
     e54:	f04f 02aa 	mov.w	r2, #170	; 0xaa
     e58:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  LPC_SC->PLL0FEED  = 0x55;
     e5c:	f24c 0300 	movw	r3, #49152	; 0xc000
     e60:	f2c4 030f 	movt	r3, #16399	; 0x400f
     e64:	f04f 0255 	mov.w	r2, #85	; 0x55
     e68:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  while (!(LPC_SC->PLL0STAT & ((1<<25) | (1<<24))));/* Wait for PLLC0_STAT & PLLE0_STAT */
     e6c:	f24c 0300 	movw	r3, #49152	; 0xc000
     e70:	f2c4 030f 	movt	r3, #16399	; 0x400f
     e74:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
     e78:	f003 7340 	and.w	r3, r3, #50331648	; 0x3000000
     e7c:	2b00      	cmp	r3, #0
     e7e:	d0f5      	beq.n	e6c <SystemInit+0xf0>
#endif

#if (PLL1_SETUP)
  LPC_SC->PLL1CFG   = PLL1CFG_Val;
     e80:	f24c 0300 	movw	r3, #49152	; 0xc000
     e84:	f2c4 030f 	movt	r3, #16399	; 0x400f
     e88:	f04f 0223 	mov.w	r2, #35	; 0x23
     e8c:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  LPC_SC->PLL1FEED  = 0xAA;
     e90:	f24c 0300 	movw	r3, #49152	; 0xc000
     e94:	f2c4 030f 	movt	r3, #16399	; 0x400f
     e98:	f04f 02aa 	mov.w	r2, #170	; 0xaa
     e9c:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  LPC_SC->PLL1FEED  = 0x55;
     ea0:	f24c 0300 	movw	r3, #49152	; 0xc000
     ea4:	f2c4 030f 	movt	r3, #16399	; 0x400f
     ea8:	f04f 0255 	mov.w	r2, #85	; 0x55
     eac:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac

  LPC_SC->PLL1CON   = 0x01;             /* PLL1 Enable                        */
     eb0:	f24c 0300 	movw	r3, #49152	; 0xc000
     eb4:	f2c4 030f 	movt	r3, #16399	; 0x400f
     eb8:	f04f 0201 	mov.w	r2, #1
     ebc:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  LPC_SC->PLL1FEED  = 0xAA;
     ec0:	f24c 0300 	movw	r3, #49152	; 0xc000
     ec4:	f2c4 030f 	movt	r3, #16399	; 0x400f
     ec8:	f04f 02aa 	mov.w	r2, #170	; 0xaa
     ecc:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  LPC_SC->PLL1FEED  = 0x55;
     ed0:	f24c 0300 	movw	r3, #49152	; 0xc000
     ed4:	f2c4 030f 	movt	r3, #16399	; 0x400f
     ed8:	f04f 0255 	mov.w	r2, #85	; 0x55
     edc:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  while (!(LPC_SC->PLL1STAT & (1<<10)));/* Wait for PLOCK1                    */
     ee0:	f24c 0300 	movw	r3, #49152	; 0xc000
     ee4:	f2c4 030f 	movt	r3, #16399	; 0x400f
     ee8:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
     eec:	f403 6380 	and.w	r3, r3, #1024	; 0x400
     ef0:	2b00      	cmp	r3, #0
     ef2:	d0f5      	beq.n	ee0 <SystemInit+0x164>

  LPC_SC->PLL1CON   = 0x03;             /* PLL1 Enable & Connect              */
     ef4:	f24c 0300 	movw	r3, #49152	; 0xc000
     ef8:	f2c4 030f 	movt	r3, #16399	; 0x400f
     efc:	f04f 0203 	mov.w	r2, #3
     f00:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  LPC_SC->PLL1FEED  = 0xAA;
     f04:	f24c 0300 	movw	r3, #49152	; 0xc000
     f08:	f2c4 030f 	movt	r3, #16399	; 0x400f
     f0c:	f04f 02aa 	mov.w	r2, #170	; 0xaa
     f10:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  LPC_SC->PLL1FEED  = 0x55;
     f14:	f24c 0300 	movw	r3, #49152	; 0xc000
     f18:	f2c4 030f 	movt	r3, #16399	; 0x400f
     f1c:	f04f 0255 	mov.w	r2, #85	; 0x55
     f20:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  while (!(LPC_SC->PLL1STAT & ((1<< 9) | (1<< 8))));/* Wait for PLLC1_STAT & PLLE1_STAT */
     f24:	f24c 0300 	movw	r3, #49152	; 0xc000
     f28:	f2c4 030f 	movt	r3, #16399	; 0x400f
     f2c:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
     f30:	f403 7340 	and.w	r3, r3, #768	; 0x300
     f34:	2b00      	cmp	r3, #0
     f36:	d0f5      	beq.n	f24 <SystemInit+0x1a8>
#else
  LPC_SC->USBCLKCFG = USBCLKCFG_Val;    /* Setup USB Clock Divider            */
#endif

  LPC_SC->PCLKSEL0  = PCLKSEL0_Val;     /* Peripheral Clock Selection         */
     f38:	f24c 0300 	movw	r3, #49152	; 0xc000
     f3c:	f2c4 030f 	movt	r3, #16399	; 0x400f
     f40:	f04f 0200 	mov.w	r2, #0
     f44:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
  LPC_SC->PCLKSEL1  = PCLKSEL1_Val;
     f48:	f24c 0300 	movw	r3, #49152	; 0xc000
     f4c:	f2c4 030f 	movt	r3, #16399	; 0x400f
     f50:	f04f 0200 	mov.w	r2, #0
     f54:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac

  LPC_SC->PCONP     = PCONP_Val;        /* Power Control for Peripherals      */
     f58:	f24c 0300 	movw	r3, #49152	; 0xc000
     f5c:	f2c4 030f 	movt	r3, #16399	; 0x400f
     f60:	f248 72de 	movw	r2, #34782	; 0x87de
     f64:	f2c0 4228 	movt	r2, #1064	; 0x428
     f68:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4

  LPC_SC->CLKOUTCFG = CLKOUTCFG_Val;    /* Clock Output Configuration         */
     f6c:	f24c 0300 	movw	r3, #49152	; 0xc000
     f70:	f2c4 030f 	movt	r3, #16399	; 0x400f
     f74:	f04f 0200 	mov.w	r2, #0
     f78:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
#endif

#if (FLASH_SETUP == 1)                  /* Flash Accelerator Setup            */
  LPC_SC->FLASHCFG  = FLASHCFG_Val;
     f7c:	f24c 0300 	movw	r3, #49152	; 0xc000
     f80:	f2c4 030f 	movt	r3, #16399	; 0x400f
     f84:	f243 023a 	movw	r2, #12346	; 0x303a
     f88:	601a      	str	r2, [r3, #0]
#endif
}
     f8a:	46bd      	mov	sp, r7
     f8c:	bc80      	pop	{r7}
     f8e:	4770      	bx	lr

00000f90 <__get_PSP>:
 * Return the actual process stack pointer
 */
uint32_t __get_PSP(void) __attribute__( ( naked ) );
uint32_t __get_PSP(void)
{
  uint32_t result=0;
     f90:	f04f 0400 	mov.w	r4, #0

  __ASM volatile ("MRS %0, psp\n\t" 
     f94:	f3ef 8409 	mrs	r4, PSP
     f98:	4620      	mov	r0, r4
     f9a:	4770      	bx	lr
                  "MOV r0, %0 \n\t"
                  "BX  lr     \n\t"  : "=r" (result) );
  return(result);
     f9c:	4623      	mov	r3, r4
}
     f9e:	4618      	mov	r0, r3

00000fa0 <__set_PSP>:
 * Assign the value ProcessStackPointer to the MSP 
 * (process stack pointer) Cortex processor register
 */
void __set_PSP(uint32_t topOfProcStack) __attribute__( ( naked ) );
void __set_PSP(uint32_t topOfProcStack)
{
     fa0:	4603      	mov	r3, r0
  __ASM volatile ("MSR psp, %0\n\t"
     fa2:	f383 8809 	msr	PSP, r3
     fa6:	4770      	bx	lr

00000fa8 <__get_MSP>:
 * Cortex processor register
 */
uint32_t __get_MSP(void) __attribute__( ( naked ) );
uint32_t __get_MSP(void)
{
  uint32_t result=0;
     fa8:	f04f 0400 	mov.w	r4, #0

  __ASM volatile ("MRS %0, msp\n\t" 
     fac:	f3ef 8408 	mrs	r4, MSP
     fb0:	4620      	mov	r0, r4
     fb2:	4770      	bx	lr
                  "MOV r0, %0 \n\t"
                  "BX  lr     \n\t"  : "=r" (result) );
  return(result);
     fb4:	4623      	mov	r3, r4
}
     fb6:	4618      	mov	r0, r3

00000fb8 <__set_MSP>:
 * Assign the value mainStackPointer to the MSP 
 * (main stack pointer) Cortex processor register
 */
void __set_MSP(uint32_t topOfMainStack) __attribute__( ( naked ) );
void __set_MSP(uint32_t topOfMainStack)
{
     fb8:	4603      	mov	r3, r0
  __ASM volatile ("MSR msp, %0\n\t"
     fba:	f383 8808 	msr	MSP, r3
     fbe:	4770      	bx	lr

00000fc0 <__get_BASEPRI>:
 * @return BasePriority
 *
 * Return the content of the base priority register
 */
uint32_t __get_BASEPRI(void)
{
     fc0:	b480      	push	{r7}
     fc2:	b083      	sub	sp, #12
     fc4:	af00      	add	r7, sp, #0
  uint32_t result=0;
     fc6:	f04f 0300 	mov.w	r3, #0
     fca:	607b      	str	r3, [r7, #4]
  
  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
     fcc:	f3ef 8312 	mrs	r3, BASEPRI_MASK
     fd0:	607b      	str	r3, [r7, #4]
  return(result);
     fd2:	687b      	ldr	r3, [r7, #4]
}
     fd4:	4618      	mov	r0, r3
     fd6:	f107 070c 	add.w	r7, r7, #12
     fda:	46bd      	mov	sp, r7
     fdc:	bc80      	pop	{r7}
     fde:	4770      	bx	lr

00000fe0 <__set_BASEPRI>:
 * @param  basePri  BasePriority
 *
 * Set the base priority register
 */
void __set_BASEPRI(uint32_t value)
{
     fe0:	b480      	push	{r7}
     fe2:	b083      	sub	sp, #12
     fe4:	af00      	add	r7, sp, #0
     fe6:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
     fe8:	687b      	ldr	r3, [r7, #4]
     fea:	f383 8811 	msr	BASEPRI, r3
}
     fee:	f107 070c 	add.w	r7, r7, #12
     ff2:	46bd      	mov	sp, r7
     ff4:	bc80      	pop	{r7}
     ff6:	4770      	bx	lr

00000ff8 <__get_PRIMASK>:
 * @return PriMask
 *
 * Return state of the priority mask bit from the priority mask register
 */
uint32_t __get_PRIMASK(void)
{
     ff8:	b480      	push	{r7}
     ffa:	b083      	sub	sp, #12
     ffc:	af00      	add	r7, sp, #0
  uint32_t result=0;
     ffe:	f04f 0300 	mov.w	r3, #0
    1002:	607b      	str	r3, [r7, #4]

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    1004:	f3ef 8310 	mrs	r3, PRIMASK
    1008:	607b      	str	r3, [r7, #4]
  return(result);
    100a:	687b      	ldr	r3, [r7, #4]
}
    100c:	4618      	mov	r0, r3
    100e:	f107 070c 	add.w	r7, r7, #12
    1012:	46bd      	mov	sp, r7
    1014:	bc80      	pop	{r7}
    1016:	4770      	bx	lr

00001018 <__set_PRIMASK>:
 * @param  priMask  PriMask
 *
 * Set the priority mask bit in the priority mask register
 */
void __set_PRIMASK(uint32_t priMask)
{
    1018:	b480      	push	{r7}
    101a:	b083      	sub	sp, #12
    101c:	af00      	add	r7, sp, #0
    101e:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
    1020:	687b      	ldr	r3, [r7, #4]
    1022:	f383 8810 	msr	PRIMASK, r3
}
    1026:	f107 070c 	add.w	r7, r7, #12
    102a:	46bd      	mov	sp, r7
    102c:	bc80      	pop	{r7}
    102e:	4770      	bx	lr

00001030 <__get_FAULTMASK>:
 * @return FaultMask
 *
 * Return the content of the fault mask register
 */
uint32_t __get_FAULTMASK(void)
{
    1030:	b480      	push	{r7}
    1032:	b083      	sub	sp, #12
    1034:	af00      	add	r7, sp, #0
  uint32_t result=0;
    1036:	f04f 0300 	mov.w	r3, #0
    103a:	607b      	str	r3, [r7, #4]
  
  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
    103c:	f3ef 8313 	mrs	r3, FAULTMASK
    1040:	607b      	str	r3, [r7, #4]
  return(result);
    1042:	687b      	ldr	r3, [r7, #4]
}
    1044:	4618      	mov	r0, r3
    1046:	f107 070c 	add.w	r7, r7, #12
    104a:	46bd      	mov	sp, r7
    104c:	bc80      	pop	{r7}
    104e:	4770      	bx	lr

00001050 <__set_FAULTMASK>:
 * @param  faultMask  faultMask value
 *
 * Set the fault mask register
 */
void __set_FAULTMASK(uint32_t faultMask)
{
    1050:	b480      	push	{r7}
    1052:	b083      	sub	sp, #12
    1054:	af00      	add	r7, sp, #0
    1056:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
    1058:	687b      	ldr	r3, [r7, #4]
    105a:	f383 8813 	msr	FAULTMASK, r3
}
    105e:	f107 070c 	add.w	r7, r7, #12
    1062:	46bd      	mov	sp, r7
    1064:	bc80      	pop	{r7}
    1066:	4770      	bx	lr

00001068 <__get_CONTROL>:
*  @return Control value
 *
 * Return the content of the control register
 */
uint32_t __get_CONTROL(void)
{
    1068:	b480      	push	{r7}
    106a:	b083      	sub	sp, #12
    106c:	af00      	add	r7, sp, #0
  uint32_t result=0;
    106e:	f04f 0300 	mov.w	r3, #0
    1072:	607b      	str	r3, [r7, #4]

  __ASM volatile ("MRS %0, control" : "=r" (result) );
    1074:	f3ef 8314 	mrs	r3, CONTROL
    1078:	607b      	str	r3, [r7, #4]
  return(result);
    107a:	687b      	ldr	r3, [r7, #4]
}
    107c:	4618      	mov	r0, r3
    107e:	f107 070c 	add.w	r7, r7, #12
    1082:	46bd      	mov	sp, r7
    1084:	bc80      	pop	{r7}
    1086:	4770      	bx	lr

00001088 <__set_CONTROL>:
 * @param  control  Control value
 *
 * Set the control register
 */
void __set_CONTROL(uint32_t control)
{
    1088:	b480      	push	{r7}
    108a:	b083      	sub	sp, #12
    108c:	af00      	add	r7, sp, #0
    108e:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR control, %0" : : "r" (control) );
    1090:	687b      	ldr	r3, [r7, #4]
    1092:	f383 8814 	msr	CONTROL, r3
}
    1096:	f107 070c 	add.w	r7, r7, #12
    109a:	46bd      	mov	sp, r7
    109c:	bc80      	pop	{r7}
    109e:	4770      	bx	lr

000010a0 <__REV>:
 * @return        reversed value
 *
 * Reverse byte order in integer value
 */
uint32_t __REV(uint32_t value)
{
    10a0:	b480      	push	{r7}
    10a2:	b085      	sub	sp, #20
    10a4:	af00      	add	r7, sp, #0
    10a6:	6078      	str	r0, [r7, #4]
  uint32_t result=0;
    10a8:	f04f 0300 	mov.w	r3, #0
    10ac:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
    10ae:	687b      	ldr	r3, [r7, #4]
    10b0:	ba1b      	rev	r3, r3
    10b2:	60fb      	str	r3, [r7, #12]
  return(result);
    10b4:	68fb      	ldr	r3, [r7, #12]
}
    10b6:	4618      	mov	r0, r3
    10b8:	f107 0714 	add.w	r7, r7, #20
    10bc:	46bd      	mov	sp, r7
    10be:	bc80      	pop	{r7}
    10c0:	4770      	bx	lr
    10c2:	bf00      	nop

000010c4 <__REV16>:
 * @return        reversed value
 *
 * Reverse byte order in unsigned short value
 */
uint32_t __REV16(uint16_t value)
{
    10c4:	b480      	push	{r7}
    10c6:	b085      	sub	sp, #20
    10c8:	af00      	add	r7, sp, #0
    10ca:	4603      	mov	r3, r0
    10cc:	80fb      	strh	r3, [r7, #6]
  uint32_t result=0;
    10ce:	f04f 0300 	mov.w	r3, #0
    10d2:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
    10d4:	88fb      	ldrh	r3, [r7, #6]
    10d6:	ba5b      	rev16	r3, r3
    10d8:	60fb      	str	r3, [r7, #12]
  return(result);
    10da:	68fb      	ldr	r3, [r7, #12]
}
    10dc:	4618      	mov	r0, r3
    10de:	f107 0714 	add.w	r7, r7, #20
    10e2:	46bd      	mov	sp, r7
    10e4:	bc80      	pop	{r7}
    10e6:	4770      	bx	lr

000010e8 <__REVSH>:
 * @return        reversed value
 *
 * Reverse byte order in signed short value with sign extension to integer
 */
int32_t __REVSH(int16_t value)
{
    10e8:	b480      	push	{r7}
    10ea:	b085      	sub	sp, #20
    10ec:	af00      	add	r7, sp, #0
    10ee:	4603      	mov	r3, r0
    10f0:	80fb      	strh	r3, [r7, #6]
  uint32_t result=0;
    10f2:	f04f 0300 	mov.w	r3, #0
    10f6:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
    10f8:	88fb      	ldrh	r3, [r7, #6]
    10fa:	badb      	revsh	r3, r3
    10fc:	60fb      	str	r3, [r7, #12]
  return(result);
    10fe:	68fb      	ldr	r3, [r7, #12]
}
    1100:	4618      	mov	r0, r3
    1102:	f107 0714 	add.w	r7, r7, #20
    1106:	46bd      	mov	sp, r7
    1108:	bc80      	pop	{r7}
    110a:	4770      	bx	lr

0000110c <__RBIT>:
 * @return        reversed value
 *
 * Reverse bit order of value
 */
uint32_t __RBIT(uint32_t value)
{
    110c:	b480      	push	{r7}
    110e:	b085      	sub	sp, #20
    1110:	af00      	add	r7, sp, #0
    1112:	6078      	str	r0, [r7, #4]
  uint32_t result=0;
    1114:	f04f 0300 	mov.w	r3, #0
    1118:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
    111a:	687b      	ldr	r3, [r7, #4]
    111c:	fa93 f3a3 	rbit	r3, r3
    1120:	60fb      	str	r3, [r7, #12]
   return(result);
    1122:	68fb      	ldr	r3, [r7, #12]
}
    1124:	4618      	mov	r0, r3
    1126:	f107 0714 	add.w	r7, r7, #20
    112a:	46bd      	mov	sp, r7
    112c:	bc80      	pop	{r7}
    112e:	4770      	bx	lr

00001130 <__LDREXB>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 8 bit value
 */
uint8_t __LDREXB(uint8_t *addr)
{
    1130:	b480      	push	{r7}
    1132:	b085      	sub	sp, #20
    1134:	af00      	add	r7, sp, #0
    1136:	6078      	str	r0, [r7, #4]
    uint8_t result=0;
    1138:	f04f 0300 	mov.w	r3, #0
    113c:	73fb      	strb	r3, [r7, #15]
  
   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
    113e:	687b      	ldr	r3, [r7, #4]
    1140:	e8d3 3f4f 	ldrexb	r3, [r3]
    1144:	73fb      	strb	r3, [r7, #15]
   return(result);
    1146:	7bfb      	ldrb	r3, [r7, #15]
}
    1148:	4618      	mov	r0, r3
    114a:	f107 0714 	add.w	r7, r7, #20
    114e:	46bd      	mov	sp, r7
    1150:	bc80      	pop	{r7}
    1152:	4770      	bx	lr

00001154 <__LDREXH>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 16 bit values
 */
uint16_t __LDREXH(uint16_t *addr)
{
    1154:	b480      	push	{r7}
    1156:	b085      	sub	sp, #20
    1158:	af00      	add	r7, sp, #0
    115a:	6078      	str	r0, [r7, #4]
    uint16_t result=0;
    115c:	f04f 0300 	mov.w	r3, #0
    1160:	81fb      	strh	r3, [r7, #14]
  
   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
    1162:	687b      	ldr	r3, [r7, #4]
    1164:	e8d3 3f5f 	ldrexh	r3, [r3]
    1168:	81fb      	strh	r3, [r7, #14]
   return(result);
    116a:	89fb      	ldrh	r3, [r7, #14]
}
    116c:	4618      	mov	r0, r3
    116e:	f107 0714 	add.w	r7, r7, #20
    1172:	46bd      	mov	sp, r7
    1174:	bc80      	pop	{r7}
    1176:	4770      	bx	lr

00001178 <__LDREXW>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 32 bit values
 */
uint32_t __LDREXW(uint32_t *addr)
{
    1178:	b480      	push	{r7}
    117a:	b085      	sub	sp, #20
    117c:	af00      	add	r7, sp, #0
    117e:	6078      	str	r0, [r7, #4]
    uint32_t result=0;
    1180:	f04f 0300 	mov.w	r3, #0
    1184:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    1186:	687b      	ldr	r3, [r7, #4]
    1188:	e853 3f00 	ldrex	r3, [r3]
    118c:	60fb      	str	r3, [r7, #12]
   return(result);
    118e:	68fb      	ldr	r3, [r7, #12]
}
    1190:	4618      	mov	r0, r3
    1192:	f107 0714 	add.w	r7, r7, #20
    1196:	46bd      	mov	sp, r7
    1198:	bc80      	pop	{r7}
    119a:	4770      	bx	lr

0000119c <__STREXB>:
 * @return        successful / failed
 *
 * Exclusive STR command for 8 bit values
 */
uint32_t __STREXB(uint8_t value, uint8_t *addr)
{
    119c:	b480      	push	{r7}
    119e:	b085      	sub	sp, #20
    11a0:	af00      	add	r7, sp, #0
    11a2:	4603      	mov	r3, r0
    11a4:	6039      	str	r1, [r7, #0]
    11a6:	71fb      	strb	r3, [r7, #7]
   uint32_t result=0;
    11a8:	f04f 0300 	mov.w	r3, #0
    11ac:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strexb %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
    11ae:	683b      	ldr	r3, [r7, #0]
    11b0:	79fa      	ldrb	r2, [r7, #7]
    11b2:	e8c3 2f43 	strexb	r3, r2, [r3]
    11b6:	60fb      	str	r3, [r7, #12]
   return(result);
    11b8:	68fb      	ldr	r3, [r7, #12]
}
    11ba:	4618      	mov	r0, r3
    11bc:	f107 0714 	add.w	r7, r7, #20
    11c0:	46bd      	mov	sp, r7
    11c2:	bc80      	pop	{r7}
    11c4:	4770      	bx	lr
    11c6:	bf00      	nop

000011c8 <__STREXH>:
 * @return        successful / failed
 *
 * Exclusive STR command for 16 bit values
 */
uint32_t __STREXH(uint16_t value, uint16_t *addr)
{
    11c8:	b480      	push	{r7}
    11ca:	b085      	sub	sp, #20
    11cc:	af00      	add	r7, sp, #0
    11ce:	4603      	mov	r3, r0
    11d0:	6039      	str	r1, [r7, #0]
    11d2:	80fb      	strh	r3, [r7, #6]
   uint32_t result=0;
    11d4:	f04f 0300 	mov.w	r3, #0
    11d8:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strexh %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
    11da:	683b      	ldr	r3, [r7, #0]
    11dc:	88fa      	ldrh	r2, [r7, #6]
    11de:	e8c3 2f53 	strexh	r3, r2, [r3]
    11e2:	60fb      	str	r3, [r7, #12]
   return(result);
    11e4:	68fb      	ldr	r3, [r7, #12]
}
    11e6:	4618      	mov	r0, r3
    11e8:	f107 0714 	add.w	r7, r7, #20
    11ec:	46bd      	mov	sp, r7
    11ee:	bc80      	pop	{r7}
    11f0:	4770      	bx	lr
    11f2:	bf00      	nop

000011f4 <__STREXW>:
 * @return        successful / failed
 *
 * Exclusive STR command for 32 bit values
 */
uint32_t __STREXW(uint32_t value, uint32_t *addr)
{
    11f4:	b480      	push	{r7}
    11f6:	b085      	sub	sp, #20
    11f8:	af00      	add	r7, sp, #0
    11fa:	6078      	str	r0, [r7, #4]
    11fc:	6039      	str	r1, [r7, #0]
   uint32_t result=0;
    11fe:	f04f 0300 	mov.w	r3, #0
    1202:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strex %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
    1204:	683b      	ldr	r3, [r7, #0]
    1206:	687a      	ldr	r2, [r7, #4]
    1208:	e843 2300 	strex	r3, r2, [r3]
    120c:	60fb      	str	r3, [r7, #12]
   return(result);
    120e:	68fb      	ldr	r3, [r7, #12]
}
    1210:	4618      	mov	r0, r3
    1212:	f107 0714 	add.w	r7, r7, #20
    1216:	46bd      	mov	sp, r7
    1218:	bc80      	pop	{r7}
    121a:	4770      	bx	lr

0000121c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    121c:	b480      	push	{r7}
    121e:	b083      	sub	sp, #12
    1220:	af00      	add	r7, sp, #0
    1222:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1224:	687b      	ldr	r3, [r7, #4]
    1226:	f103 0308 	add.w	r3, r3, #8
    122a:	461a      	mov	r2, r3
    122c:	687b      	ldr	r3, [r7, #4]
    122e:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1230:	687b      	ldr	r3, [r7, #4]
    1232:	f04f 32ff 	mov.w	r2, #4294967295
    1236:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1238:	687b      	ldr	r3, [r7, #4]
    123a:	f103 0308 	add.w	r3, r3, #8
    123e:	461a      	mov	r2, r3
    1240:	687b      	ldr	r3, [r7, #4]
    1242:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1244:	687b      	ldr	r3, [r7, #4]
    1246:	f103 0308 	add.w	r3, r3, #8
    124a:	461a      	mov	r2, r3
    124c:	687b      	ldr	r3, [r7, #4]
    124e:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = 0;
    1250:	687b      	ldr	r3, [r7, #4]
    1252:	f04f 0200 	mov.w	r2, #0
    1256:	601a      	str	r2, [r3, #0]
}
    1258:	f107 070c 	add.w	r7, r7, #12
    125c:	46bd      	mov	sp, r7
    125e:	bc80      	pop	{r7}
    1260:	4770      	bx	lr
    1262:	bf00      	nop

00001264 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    1264:	b480      	push	{r7}
    1266:	b083      	sub	sp, #12
    1268:	af00      	add	r7, sp, #0
    126a:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    126c:	687b      	ldr	r3, [r7, #4]
    126e:	f04f 0200 	mov.w	r2, #0
    1272:	611a      	str	r2, [r3, #16]
}
    1274:	f107 070c 	add.w	r7, r7, #12
    1278:	46bd      	mov	sp, r7
    127a:	bc80      	pop	{r7}
    127c:	4770      	bx	lr
    127e:	bf00      	nop

00001280 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1280:	b480      	push	{r7}
    1282:	b085      	sub	sp, #20
    1284:	af00      	add	r7, sp, #0
    1286:	6078      	str	r0, [r7, #4]
    1288:	6039      	str	r1, [r7, #0]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    128a:	687b      	ldr	r3, [r7, #4]
    128c:	685b      	ldr	r3, [r3, #4]
    128e:	60fb      	str	r3, [r7, #12]

	pxNewListItem->pxNext = pxIndex->pxNext;
    1290:	68fb      	ldr	r3, [r7, #12]
    1292:	685a      	ldr	r2, [r3, #4]
    1294:	683b      	ldr	r3, [r7, #0]
    1296:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1298:	687b      	ldr	r3, [r7, #4]
    129a:	685a      	ldr	r2, [r3, #4]
    129c:	683b      	ldr	r3, [r7, #0]
    129e:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    12a0:	68fb      	ldr	r3, [r7, #12]
    12a2:	685b      	ldr	r3, [r3, #4]
    12a4:	683a      	ldr	r2, [r7, #0]
    12a6:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    12a8:	683a      	ldr	r2, [r7, #0]
    12aa:	68fb      	ldr	r3, [r7, #12]
    12ac:	605a      	str	r2, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    12ae:	683a      	ldr	r2, [r7, #0]
    12b0:	687b      	ldr	r3, [r7, #4]
    12b2:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    12b4:	683b      	ldr	r3, [r7, #0]
    12b6:	687a      	ldr	r2, [r7, #4]
    12b8:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
    12ba:	687b      	ldr	r3, [r7, #4]
    12bc:	681b      	ldr	r3, [r3, #0]
    12be:	f103 0201 	add.w	r2, r3, #1
    12c2:	687b      	ldr	r3, [r7, #4]
    12c4:	601a      	str	r2, [r3, #0]
}
    12c6:	f107 0714 	add.w	r7, r7, #20
    12ca:	46bd      	mov	sp, r7
    12cc:	bc80      	pop	{r7}
    12ce:	4770      	bx	lr

000012d0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    12d0:	b480      	push	{r7}
    12d2:	b085      	sub	sp, #20
    12d4:	af00      	add	r7, sp, #0
    12d6:	6078      	str	r0, [r7, #4]
    12d8:	6039      	str	r1, [r7, #0]
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    12da:	683b      	ldr	r3, [r7, #0]
    12dc:	681b      	ldr	r3, [r3, #0]
    12de:	60fb      	str	r3, [r7, #12]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    12e0:	68fb      	ldr	r3, [r7, #12]
    12e2:	f1b3 3fff 	cmp.w	r3, #4294967295
    12e6:	d103      	bne.n	12f0 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    12e8:	687b      	ldr	r3, [r7, #4]
    12ea:	691b      	ldr	r3, [r3, #16]
    12ec:	60bb      	str	r3, [r7, #8]
    12ee:	e00d      	b.n	130c <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    12f0:	687b      	ldr	r3, [r7, #4]
    12f2:	f103 0308 	add.w	r3, r3, #8
    12f6:	60bb      	str	r3, [r7, #8]
    12f8:	e002      	b.n	1300 <vListInsert+0x30>
    12fa:	68bb      	ldr	r3, [r7, #8]
    12fc:	685b      	ldr	r3, [r3, #4]
    12fe:	60bb      	str	r3, [r7, #8]
    1300:	68bb      	ldr	r3, [r7, #8]
    1302:	685b      	ldr	r3, [r3, #4]
    1304:	681a      	ldr	r2, [r3, #0]
    1306:	68fb      	ldr	r3, [r7, #12]
    1308:	429a      	cmp	r2, r3
    130a:	d9f6      	bls.n	12fa <vListInsert+0x2a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    130c:	68bb      	ldr	r3, [r7, #8]
    130e:	685a      	ldr	r2, [r3, #4]
    1310:	683b      	ldr	r3, [r7, #0]
    1312:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1314:	683b      	ldr	r3, [r7, #0]
    1316:	685b      	ldr	r3, [r3, #4]
    1318:	683a      	ldr	r2, [r7, #0]
    131a:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
    131c:	683b      	ldr	r3, [r7, #0]
    131e:	68ba      	ldr	r2, [r7, #8]
    1320:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1322:	683a      	ldr	r2, [r7, #0]
    1324:	68bb      	ldr	r3, [r7, #8]
    1326:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1328:	683b      	ldr	r3, [r7, #0]
    132a:	687a      	ldr	r2, [r7, #4]
    132c:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
    132e:	687b      	ldr	r3, [r7, #4]
    1330:	681b      	ldr	r3, [r3, #0]
    1332:	f103 0201 	add.w	r2, r3, #1
    1336:	687b      	ldr	r3, [r7, #4]
    1338:	601a      	str	r2, [r3, #0]
}
    133a:	f107 0714 	add.w	r7, r7, #20
    133e:	46bd      	mov	sp, r7
    1340:	bc80      	pop	{r7}
    1342:	4770      	bx	lr

00001344 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1344:	b480      	push	{r7}
    1346:	b085      	sub	sp, #20
    1348:	af00      	add	r7, sp, #0
    134a:	6078      	str	r0, [r7, #4]
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    134c:	687b      	ldr	r3, [r7, #4]
    134e:	685b      	ldr	r3, [r3, #4]
    1350:	687a      	ldr	r2, [r7, #4]
    1352:	6892      	ldr	r2, [r2, #8]
    1354:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1356:	687b      	ldr	r3, [r7, #4]
    1358:	689b      	ldr	r3, [r3, #8]
    135a:	687a      	ldr	r2, [r7, #4]
    135c:	6852      	ldr	r2, [r2, #4]
    135e:	605a      	str	r2, [r3, #4]
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1360:	687b      	ldr	r3, [r7, #4]
    1362:	691b      	ldr	r3, [r3, #16]
    1364:	60fb      	str	r3, [r7, #12]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1366:	68fb      	ldr	r3, [r7, #12]
    1368:	685a      	ldr	r2, [r3, #4]
    136a:	687b      	ldr	r3, [r7, #4]
    136c:	429a      	cmp	r2, r3
    136e:	d103      	bne.n	1378 <vListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1370:	687b      	ldr	r3, [r7, #4]
    1372:	689a      	ldr	r2, [r3, #8]
    1374:	68fb      	ldr	r3, [r7, #12]
    1376:	605a      	str	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
    1378:	687b      	ldr	r3, [r7, #4]
    137a:	f04f 0200 	mov.w	r2, #0
    137e:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
    1380:	68fb      	ldr	r3, [r7, #12]
    1382:	681b      	ldr	r3, [r3, #0]
    1384:	f103 32ff 	add.w	r2, r3, #4294967295
    1388:	68fb      	ldr	r3, [r7, #12]
    138a:	601a      	str	r2, [r3, #0]
}
    138c:	f107 0714 	add.w	r7, r7, #20
    1390:	46bd      	mov	sp, r7
    1392:	bc80      	pop	{r7}
    1394:	4770      	bx	lr
    1396:	bf00      	nop

00001398 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1398:	b580      	push	{r7, lr}
    139a:	b084      	sub	sp, #16
    139c:	af00      	add	r7, sp, #0
    139e:	6078      	str	r0, [r7, #4]
    13a0:	6039      	str	r1, [r7, #0]
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    13a2:	687b      	ldr	r3, [r7, #4]
    13a4:	2b00      	cmp	r3, #0
    13a6:	d055      	beq.n	1454 <xQueueCreate+0xbc>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    13a8:	f04f 004c 	mov.w	r0, #76	; 0x4c
    13ac:	f001 fba6 	bl	2afc <pvPortMalloc>
    13b0:	4603      	mov	r3, r0
    13b2:	60bb      	str	r3, [r7, #8]
		if( pxNewQueue != NULL )
    13b4:	68bb      	ldr	r3, [r7, #8]
    13b6:	2b00      	cmp	r3, #0
    13b8:	d04c      	beq.n	1454 <xQueueCreate+0xbc>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    13ba:	687b      	ldr	r3, [r7, #4]
    13bc:	683a      	ldr	r2, [r7, #0]
    13be:	fb02 f303 	mul.w	r3, r2, r3
    13c2:	f103 0301 	add.w	r3, r3, #1
    13c6:	60fb      	str	r3, [r7, #12]

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    13c8:	68f8      	ldr	r0, [r7, #12]
    13ca:	f001 fb97 	bl	2afc <pvPortMalloc>
    13ce:	4603      	mov	r3, r0
    13d0:	461a      	mov	r2, r3
    13d2:	68bb      	ldr	r3, [r7, #8]
    13d4:	601a      	str	r2, [r3, #0]
			if( pxNewQueue->pcHead != NULL )
    13d6:	68bb      	ldr	r3, [r7, #8]
    13d8:	681b      	ldr	r3, [r3, #0]
    13da:	2b00      	cmp	r3, #0
    13dc:	d037      	beq.n	144e <xQueueCreate+0xb6>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    13de:	68bb      	ldr	r3, [r7, #8]
    13e0:	681a      	ldr	r2, [r3, #0]
    13e2:	687b      	ldr	r3, [r7, #4]
    13e4:	6839      	ldr	r1, [r7, #0]
    13e6:	fb01 f303 	mul.w	r3, r1, r3
    13ea:	441a      	add	r2, r3
    13ec:	68bb      	ldr	r3, [r7, #8]
    13ee:	605a      	str	r2, [r3, #4]
				pxNewQueue->uxMessagesWaiting = 0;
    13f0:	68bb      	ldr	r3, [r7, #8]
    13f2:	f04f 0200 	mov.w	r2, #0
    13f6:	639a      	str	r2, [r3, #56]	; 0x38
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    13f8:	68bb      	ldr	r3, [r7, #8]
    13fa:	681a      	ldr	r2, [r3, #0]
    13fc:	68bb      	ldr	r3, [r7, #8]
    13fe:	609a      	str	r2, [r3, #8]
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    1400:	68bb      	ldr	r3, [r7, #8]
    1402:	681a      	ldr	r2, [r3, #0]
    1404:	687b      	ldr	r3, [r7, #4]
    1406:	f103 33ff 	add.w	r3, r3, #4294967295
    140a:	6839      	ldr	r1, [r7, #0]
    140c:	fb01 f303 	mul.w	r3, r1, r3
    1410:	441a      	add	r2, r3
    1412:	68bb      	ldr	r3, [r7, #8]
    1414:	60da      	str	r2, [r3, #12]
				pxNewQueue->uxLength = uxQueueLength;
    1416:	68bb      	ldr	r3, [r7, #8]
    1418:	687a      	ldr	r2, [r7, #4]
    141a:	63da      	str	r2, [r3, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
    141c:	68bb      	ldr	r3, [r7, #8]
    141e:	683a      	ldr	r2, [r7, #0]
    1420:	641a      	str	r2, [r3, #64]	; 0x40
				pxNewQueue->xRxLock = queueUNLOCKED;
    1422:	68bb      	ldr	r3, [r7, #8]
    1424:	f04f 32ff 	mov.w	r2, #4294967295
    1428:	645a      	str	r2, [r3, #68]	; 0x44
				pxNewQueue->xTxLock = queueUNLOCKED;
    142a:	68bb      	ldr	r3, [r7, #8]
    142c:	f04f 32ff 	mov.w	r2, #4294967295
    1430:	649a      	str	r2, [r3, #72]	; 0x48

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1432:	68bb      	ldr	r3, [r7, #8]
    1434:	f103 0310 	add.w	r3, r3, #16
    1438:	4618      	mov	r0, r3
    143a:	f7ff feef 	bl	121c <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    143e:	68bb      	ldr	r3, [r7, #8]
    1440:	f103 0324 	add.w	r3, r3, #36	; 0x24
    1444:	4618      	mov	r0, r3
    1446:	f7ff fee9 	bl	121c <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				return  pxNewQueue;
    144a:	68bb      	ldr	r3, [r7, #8]
    144c:	e004      	b.n	1458 <xQueueCreate+0xc0>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    144e:	68b8      	ldr	r0, [r7, #8]
    1450:	f001 fc36 	bl	2cc0 <vPortFree>
		}
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
    1454:	f04f 0300 	mov.w	r3, #0
}
    1458:	4618      	mov	r0, r3
    145a:	f107 0710 	add.w	r7, r7, #16
    145e:	46bd      	mov	sp, r7
    1460:	bd80      	pop	{r7, pc}
    1462:	bf00      	nop

00001464 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1464:	b580      	push	{r7, lr}
    1466:	b088      	sub	sp, #32
    1468:	af00      	add	r7, sp, #0
    146a:	60f8      	str	r0, [r7, #12]
    146c:	60b9      	str	r1, [r7, #8]
    146e:	607a      	str	r2, [r7, #4]
    1470:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1472:	f04f 0300 	mov.w	r3, #0
    1476:	61fb      	str	r3, [r7, #28]
    1478:	e000      	b.n	147c <xQueueGenericSend+0x18>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    147a:	bf00      	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    147c:	f001 fcfa 	bl	2e74 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1480:	68fb      	ldr	r3, [r7, #12]
    1482:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    1484:	68fb      	ldr	r3, [r7, #12]
    1486:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    1488:	429a      	cmp	r2, r3
    148a:	d218      	bcs.n	14be <xQueueGenericSend+0x5a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    148c:	68f8      	ldr	r0, [r7, #12]
    148e:	68b9      	ldr	r1, [r7, #8]
    1490:	683a      	ldr	r2, [r7, #0]
    1492:	f000 f9f7 	bl	1884 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1496:	68fb      	ldr	r3, [r7, #12]
    1498:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    149a:	2b00      	cmp	r3, #0
    149c:	d00a      	beq.n	14b4 <xQueueGenericSend+0x50>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    149e:	68fb      	ldr	r3, [r7, #12]
    14a0:	f103 0324 	add.w	r3, r3, #36	; 0x24
    14a4:	4618      	mov	r0, r3
    14a6:	f001 f97b 	bl	27a0 <xTaskRemoveFromEventList>
    14aa:	4603      	mov	r3, r0
    14ac:	2b01      	cmp	r3, #1
    14ae:	d101      	bne.n	14b4 <xQueueGenericSend+0x50>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    14b0:	f001 fcd4 	bl	2e5c <vPortYieldFromISR>
					}
				}

				taskEXIT_CRITICAL();
    14b4:	f001 fcf4 	bl	2ea0 <vPortExitCritical>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    14b8:	f04f 0301 	mov.w	r3, #1
    14bc:	e05d      	b.n	157a <xQueueGenericSend+0x116>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    14be:	687b      	ldr	r3, [r7, #4]
    14c0:	2b00      	cmp	r3, #0
    14c2:	d104      	bne.n	14ce <xQueueGenericSend+0x6a>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    14c4:	f001 fcec 	bl	2ea0 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    14c8:	f04f 0300 	mov.w	r3, #0
    14cc:	e055      	b.n	157a <xQueueGenericSend+0x116>
				}
				else if( xEntryTimeSet == pdFALSE )
    14ce:	69fb      	ldr	r3, [r7, #28]
    14d0:	2b00      	cmp	r3, #0
    14d2:	d107      	bne.n	14e4 <xQueueGenericSend+0x80>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    14d4:	f107 0314 	add.w	r3, r7, #20
    14d8:	4618      	mov	r0, r3
    14da:	f001 f9cb 	bl	2874 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    14de:	f04f 0301 	mov.w	r3, #1
    14e2:	61fb      	str	r3, [r7, #28]
				}
			}
		}
		taskEXIT_CRITICAL();
    14e4:	f001 fcdc 	bl	2ea0 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    14e8:	f000 ff00 	bl	22ec <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    14ec:	f001 fcc2 	bl	2e74 <vPortEnterCritical>
    14f0:	68fb      	ldr	r3, [r7, #12]
    14f2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    14f4:	f1b3 3fff 	cmp.w	r3, #4294967295
    14f8:	d103      	bne.n	1502 <xQueueGenericSend+0x9e>
    14fa:	68fb      	ldr	r3, [r7, #12]
    14fc:	f04f 0200 	mov.w	r2, #0
    1500:	645a      	str	r2, [r3, #68]	; 0x44
    1502:	68fb      	ldr	r3, [r7, #12]
    1504:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    1506:	f1b3 3fff 	cmp.w	r3, #4294967295
    150a:	d103      	bne.n	1514 <xQueueGenericSend+0xb0>
    150c:	68fb      	ldr	r3, [r7, #12]
    150e:	f04f 0200 	mov.w	r2, #0
    1512:	649a      	str	r2, [r3, #72]	; 0x48
    1514:	f001 fcc4 	bl	2ea0 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1518:	f107 0214 	add.w	r2, r7, #20
    151c:	f107 0304 	add.w	r3, r7, #4
    1520:	4610      	mov	r0, r2
    1522:	4619      	mov	r1, r3
    1524:	f001 f9be 	bl	28a4 <xTaskCheckForTimeOut>
    1528:	4603      	mov	r3, r0
    152a:	2b00      	cmp	r3, #0
    152c:	d11e      	bne.n	156c <xQueueGenericSend+0x108>
		{
			if( prvIsQueueFull( pxQueue ) )
    152e:	68f8      	ldr	r0, [r7, #12]
    1530:	f000 fa9e 	bl	1a70 <prvIsQueueFull>
    1534:	4603      	mov	r3, r0
    1536:	2b00      	cmp	r3, #0
    1538:	d012      	beq.n	1560 <xQueueGenericSend+0xfc>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    153a:	68fb      	ldr	r3, [r7, #12]
    153c:	f103 0210 	add.w	r2, r3, #16
    1540:	687b      	ldr	r3, [r7, #4]
    1542:	4610      	mov	r0, r2
    1544:	4619      	mov	r1, r3
    1546:	f001 f8c1 	bl	26cc <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    154a:	68f8      	ldr	r0, [r7, #12]
    154c:	f000 fa18 	bl	1980 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    1550:	f000 fede 	bl	2310 <xTaskResumeAll>
    1554:	4603      	mov	r3, r0
    1556:	2b00      	cmp	r3, #0
    1558:	d18f      	bne.n	147a <xQueueGenericSend+0x16>
				{
					portYIELD_WITHIN_API();
    155a:	f001 fc7f 	bl	2e5c <vPortYieldFromISR>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    155e:	e78d      	b.n	147c <xQueueGenericSend+0x18>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1560:	68f8      	ldr	r0, [r7, #12]
    1562:	f000 fa0d 	bl	1980 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1566:	f000 fed3 	bl	2310 <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    156a:	e787      	b.n	147c <xQueueGenericSend+0x18>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    156c:	68f8      	ldr	r0, [r7, #12]
    156e:	f000 fa07 	bl	1980 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1572:	f000 fecd 	bl	2310 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1576:	f04f 0300 	mov.w	r3, #0
		}
	}
}
    157a:	4618      	mov	r0, r3
    157c:	f107 0720 	add.w	r7, r7, #32
    1580:	46bd      	mov	sp, r7
    1582:	bd80      	pop	{r7, pc}

00001584 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1584:	b580      	push	{r7, lr}
    1586:	b086      	sub	sp, #24
    1588:	af00      	add	r7, sp, #0
    158a:	60f8      	str	r0, [r7, #12]
    158c:	60b9      	str	r1, [r7, #8]
    158e:	607a      	str	r2, [r7, #4]
    1590:	603b      	str	r3, [r7, #0]
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1592:	f04f 0300 	mov.w	r3, #0
    1596:	617b      	str	r3, [r7, #20]
    1598:	f04f 0028 	mov.w	r0, #40	; 0x28
    159c:	f380 8811 	msr	BASEPRI, r0
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    15a0:	68fb      	ldr	r3, [r7, #12]
    15a2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    15a4:	68fb      	ldr	r3, [r7, #12]
    15a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    15a8:	429a      	cmp	r2, r3
    15aa:	d229      	bcs.n	1600 <xQueueGenericSendFromISR+0x7c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    15ac:	68f8      	ldr	r0, [r7, #12]
    15ae:	68b9      	ldr	r1, [r7, #8]
    15b0:	683a      	ldr	r2, [r7, #0]
    15b2:	f000 f967 	bl	1884 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    15b6:	68fb      	ldr	r3, [r7, #12]
    15b8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    15ba:	f1b3 3fff 	cmp.w	r3, #4294967295
    15be:	d111      	bne.n	15e4 <xQueueGenericSendFromISR+0x60>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    15c0:	68fb      	ldr	r3, [r7, #12]
    15c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    15c4:	2b00      	cmp	r3, #0
    15c6:	d014      	beq.n	15f2 <xQueueGenericSendFromISR+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15c8:	68fb      	ldr	r3, [r7, #12]
    15ca:	f103 0324 	add.w	r3, r3, #36	; 0x24
    15ce:	4618      	mov	r0, r3
    15d0:	f001 f8e6 	bl	27a0 <xTaskRemoveFromEventList>
    15d4:	4603      	mov	r3, r0
    15d6:	2b00      	cmp	r3, #0
    15d8:	d00d      	beq.n	15f6 <xQueueGenericSendFromISR+0x72>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    15da:	687b      	ldr	r3, [r7, #4]
    15dc:	f04f 0201 	mov.w	r2, #1
    15e0:	601a      	str	r2, [r3, #0]
    15e2:	e009      	b.n	15f8 <xQueueGenericSendFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    15e4:	68fb      	ldr	r3, [r7, #12]
    15e6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    15e8:	f103 0201 	add.w	r2, r3, #1
    15ec:	68fb      	ldr	r3, [r7, #12]
    15ee:	649a      	str	r2, [r3, #72]	; 0x48
    15f0:	e002      	b.n	15f8 <xQueueGenericSendFromISR+0x74>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    15f2:	bf00      	nop
    15f4:	e000      	b.n	15f8 <xQueueGenericSendFromISR+0x74>
    15f6:	bf00      	nop
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    15f8:	f04f 0301 	mov.w	r3, #1
    15fc:	613b      	str	r3, [r7, #16]
    15fe:	e002      	b.n	1606 <xQueueGenericSendFromISR+0x82>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1600:	f04f 0300 	mov.w	r3, #0
    1604:	613b      	str	r3, [r7, #16]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    1606:	f04f 0000 	mov.w	r0, #0
    160a:	f380 8811 	msr	BASEPRI, r0

	return xReturn;
    160e:	693b      	ldr	r3, [r7, #16]
}
    1610:	4618      	mov	r0, r3
    1612:	f107 0718 	add.w	r7, r7, #24
    1616:	46bd      	mov	sp, r7
    1618:	bd80      	pop	{r7, pc}
    161a:	bf00      	nop

0000161c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    161c:	b580      	push	{r7, lr}
    161e:	b088      	sub	sp, #32
    1620:	af00      	add	r7, sp, #0
    1622:	60f8      	str	r0, [r7, #12]
    1624:	60b9      	str	r1, [r7, #8]
    1626:	607a      	str	r2, [r7, #4]
    1628:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    162a:	f04f 0300 	mov.w	r3, #0
    162e:	61bb      	str	r3, [r7, #24]
    1630:	e000      	b.n	1634 <xQueueGenericReceive+0x18>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    1632:	bf00      	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1634:	f001 fc1e 	bl	2e74 <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1638:	68fb      	ldr	r3, [r7, #12]
    163a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    163c:	2b00      	cmp	r3, #0
    163e:	d03a      	beq.n	16b6 <xQueueGenericReceive+0x9a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1640:	68fb      	ldr	r3, [r7, #12]
    1642:	68db      	ldr	r3, [r3, #12]
    1644:	61fb      	str	r3, [r7, #28]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1646:	68f8      	ldr	r0, [r7, #12]
    1648:	68b9      	ldr	r1, [r7, #8]
    164a:	f000 f971 	bl	1930 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    164e:	683b      	ldr	r3, [r7, #0]
    1650:	2b00      	cmp	r3, #0
    1652:	d115      	bne.n	1680 <xQueueGenericReceive+0x64>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1654:	68fb      	ldr	r3, [r7, #12]
    1656:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    1658:	f103 32ff 	add.w	r2, r3, #4294967295
    165c:	68fb      	ldr	r3, [r7, #12]
    165e:	639a      	str	r2, [r3, #56]	; 0x38
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1660:	68fb      	ldr	r3, [r7, #12]
    1662:	691b      	ldr	r3, [r3, #16]
    1664:	2b00      	cmp	r3, #0
    1666:	d01e      	beq.n	16a6 <xQueueGenericReceive+0x8a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1668:	68fb      	ldr	r3, [r7, #12]
    166a:	f103 0310 	add.w	r3, r3, #16
    166e:	4618      	mov	r0, r3
    1670:	f001 f896 	bl	27a0 <xTaskRemoveFromEventList>
    1674:	4603      	mov	r3, r0
    1676:	2b01      	cmp	r3, #1
    1678:	d117      	bne.n	16aa <xQueueGenericReceive+0x8e>
						{
							portYIELD_WITHIN_API();
    167a:	f001 fbef 	bl	2e5c <vPortYieldFromISR>
    167e:	e015      	b.n	16ac <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1680:	68fb      	ldr	r3, [r7, #12]
    1682:	69fa      	ldr	r2, [r7, #28]
    1684:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1686:	68fb      	ldr	r3, [r7, #12]
    1688:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    168a:	2b00      	cmp	r3, #0
    168c:	d00e      	beq.n	16ac <xQueueGenericReceive+0x90>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    168e:	68fb      	ldr	r3, [r7, #12]
    1690:	f103 0324 	add.w	r3, r3, #36	; 0x24
    1694:	4618      	mov	r0, r3
    1696:	f001 f883 	bl	27a0 <xTaskRemoveFromEventList>
    169a:	4603      	mov	r3, r0
    169c:	2b00      	cmp	r3, #0
    169e:	d005      	beq.n	16ac <xQueueGenericReceive+0x90>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    16a0:	f001 fbdc 	bl	2e5c <vPortYieldFromISR>
    16a4:	e002      	b.n	16ac <xQueueGenericReceive+0x90>

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
						{
							portYIELD_WITHIN_API();
    16a6:	bf00      	nop
    16a8:	e000      	b.n	16ac <xQueueGenericReceive+0x90>
    16aa:	bf00      	nop
						}
					}

				}

				taskEXIT_CRITICAL();
    16ac:	f001 fbf8 	bl	2ea0 <vPortExitCritical>
				return pdPASS;
    16b0:	f04f 0301 	mov.w	r3, #1
    16b4:	e05e      	b.n	1774 <xQueueGenericReceive+0x158>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    16b6:	687b      	ldr	r3, [r7, #4]
    16b8:	2b00      	cmp	r3, #0
    16ba:	d104      	bne.n	16c6 <xQueueGenericReceive+0xaa>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    16bc:	f001 fbf0 	bl	2ea0 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    16c0:	f04f 0300 	mov.w	r3, #0
    16c4:	e056      	b.n	1774 <xQueueGenericReceive+0x158>
				}
				else if( xEntryTimeSet == pdFALSE )
    16c6:	69bb      	ldr	r3, [r7, #24]
    16c8:	2b00      	cmp	r3, #0
    16ca:	d107      	bne.n	16dc <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    16cc:	f107 0310 	add.w	r3, r7, #16
    16d0:	4618      	mov	r0, r3
    16d2:	f001 f8cf 	bl	2874 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    16d6:	f04f 0301 	mov.w	r3, #1
    16da:	61bb      	str	r3, [r7, #24]
				}
			}
		}
		taskEXIT_CRITICAL();
    16dc:	f001 fbe0 	bl	2ea0 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    16e0:	f000 fe04 	bl	22ec <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    16e4:	f001 fbc6 	bl	2e74 <vPortEnterCritical>
    16e8:	68fb      	ldr	r3, [r7, #12]
    16ea:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    16ec:	f1b3 3fff 	cmp.w	r3, #4294967295
    16f0:	d103      	bne.n	16fa <xQueueGenericReceive+0xde>
    16f2:	68fb      	ldr	r3, [r7, #12]
    16f4:	f04f 0200 	mov.w	r2, #0
    16f8:	645a      	str	r2, [r3, #68]	; 0x44
    16fa:	68fb      	ldr	r3, [r7, #12]
    16fc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    16fe:	f1b3 3fff 	cmp.w	r3, #4294967295
    1702:	d103      	bne.n	170c <xQueueGenericReceive+0xf0>
    1704:	68fb      	ldr	r3, [r7, #12]
    1706:	f04f 0200 	mov.w	r2, #0
    170a:	649a      	str	r2, [r3, #72]	; 0x48
    170c:	f001 fbc8 	bl	2ea0 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1710:	f107 0210 	add.w	r2, r7, #16
    1714:	f107 0304 	add.w	r3, r7, #4
    1718:	4610      	mov	r0, r2
    171a:	4619      	mov	r1, r3
    171c:	f001 f8c2 	bl	28a4 <xTaskCheckForTimeOut>
    1720:	4603      	mov	r3, r0
    1722:	2b00      	cmp	r3, #0
    1724:	d11f      	bne.n	1766 <xQueueGenericReceive+0x14a>
		{
			if( prvIsQueueEmpty( pxQueue ) )
    1726:	68f8      	ldr	r0, [r7, #12]
    1728:	f000 f97a 	bl	1a20 <prvIsQueueEmpty>
    172c:	4603      	mov	r3, r0
    172e:	2b00      	cmp	r3, #0
    1730:	d013      	beq.n	175a <xQueueGenericReceive+0x13e>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1732:	68fb      	ldr	r3, [r7, #12]
    1734:	f103 0224 	add.w	r2, r3, #36	; 0x24
    1738:	687b      	ldr	r3, [r7, #4]
    173a:	4610      	mov	r0, r2
    173c:	4619      	mov	r1, r3
    173e:	f000 ffc5 	bl	26cc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1742:	68f8      	ldr	r0, [r7, #12]
    1744:	f000 f91c 	bl	1980 <prvUnlockQueue>
				if( !xTaskResumeAll() )
    1748:	f000 fde2 	bl	2310 <xTaskResumeAll>
    174c:	4603      	mov	r3, r0
    174e:	2b00      	cmp	r3, #0
    1750:	f47f af6f 	bne.w	1632 <xQueueGenericReceive+0x16>
				{
					portYIELD_WITHIN_API();
    1754:	f001 fb82 	bl	2e5c <vPortYieldFromISR>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    1758:	e76c      	b.n	1634 <xQueueGenericReceive+0x18>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    175a:	68f8      	ldr	r0, [r7, #12]
    175c:	f000 f910 	bl	1980 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1760:	f000 fdd6 	bl	2310 <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    1764:	e766      	b.n	1634 <xQueueGenericReceive+0x18>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1766:	68f8      	ldr	r0, [r7, #12]
    1768:	f000 f90a 	bl	1980 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    176c:	f000 fdd0 	bl	2310 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1770:	f04f 0300 	mov.w	r3, #0
		}
	}
}
    1774:	4618      	mov	r0, r3
    1776:	f107 0720 	add.w	r7, r7, #32
    177a:	46bd      	mov	sp, r7
    177c:	bd80      	pop	{r7, pc}
    177e:	bf00      	nop

00001780 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1780:	b580      	push	{r7, lr}
    1782:	b086      	sub	sp, #24
    1784:	af00      	add	r7, sp, #0
    1786:	60f8      	str	r0, [r7, #12]
    1788:	60b9      	str	r1, [r7, #8]
    178a:	607a      	str	r2, [r7, #4]
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    178c:	f04f 0300 	mov.w	r3, #0
    1790:	617b      	str	r3, [r7, #20]
    1792:	f04f 0028 	mov.w	r0, #40	; 0x28
    1796:	f380 8811 	msr	BASEPRI, r0
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    179a:	68fb      	ldr	r3, [r7, #12]
    179c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    179e:	2b00      	cmp	r3, #0
    17a0:	d02e      	beq.n	1800 <xQueueReceiveFromISR+0x80>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    17a2:	68f8      	ldr	r0, [r7, #12]
    17a4:	68b9      	ldr	r1, [r7, #8]
    17a6:	f000 f8c3 	bl	1930 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    17aa:	68fb      	ldr	r3, [r7, #12]
    17ac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    17ae:	f103 32ff 	add.w	r2, r3, #4294967295
    17b2:	68fb      	ldr	r3, [r7, #12]
    17b4:	639a      	str	r2, [r3, #56]	; 0x38

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    17b6:	68fb      	ldr	r3, [r7, #12]
    17b8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    17ba:	f1b3 3fff 	cmp.w	r3, #4294967295
    17be:	d111      	bne.n	17e4 <xQueueReceiveFromISR+0x64>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    17c0:	68fb      	ldr	r3, [r7, #12]
    17c2:	691b      	ldr	r3, [r3, #16]
    17c4:	2b00      	cmp	r3, #0
    17c6:	d014      	beq.n	17f2 <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17c8:	68fb      	ldr	r3, [r7, #12]
    17ca:	f103 0310 	add.w	r3, r3, #16
    17ce:	4618      	mov	r0, r3
    17d0:	f000 ffe6 	bl	27a0 <xTaskRemoveFromEventList>
    17d4:	4603      	mov	r3, r0
    17d6:	2b00      	cmp	r3, #0
    17d8:	d00d      	beq.n	17f6 <xQueueReceiveFromISR+0x76>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    17da:	687b      	ldr	r3, [r7, #4]
    17dc:	f04f 0201 	mov.w	r2, #1
    17e0:	601a      	str	r2, [r3, #0]
    17e2:	e009      	b.n	17f8 <xQueueReceiveFromISR+0x78>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    17e4:	68fb      	ldr	r3, [r7, #12]
    17e6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    17e8:	f103 0201 	add.w	r2, r3, #1
    17ec:	68fb      	ldr	r3, [r7, #12]
    17ee:	645a      	str	r2, [r3, #68]	; 0x44
    17f0:	e002      	b.n	17f8 <xQueueReceiveFromISR+0x78>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    17f2:	bf00      	nop
    17f4:	e000      	b.n	17f8 <xQueueReceiveFromISR+0x78>
    17f6:	bf00      	nop
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    17f8:	f04f 0301 	mov.w	r3, #1
    17fc:	613b      	str	r3, [r7, #16]
    17fe:	e002      	b.n	1806 <xQueueReceiveFromISR+0x86>
		}
		else
		{
			xReturn = pdFAIL;
    1800:	f04f 0300 	mov.w	r3, #0
    1804:	613b      	str	r3, [r7, #16]
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    1806:	f04f 0000 	mov.w	r0, #0
    180a:	f380 8811 	msr	BASEPRI, r0

	return xReturn;
    180e:	693b      	ldr	r3, [r7, #16]
}
    1810:	4618      	mov	r0, r3
    1812:	f107 0718 	add.w	r7, r7, #24
    1816:	46bd      	mov	sp, r7
    1818:	bd80      	pop	{r7, pc}
    181a:	bf00      	nop

0000181c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    181c:	b580      	push	{r7, lr}
    181e:	b084      	sub	sp, #16
    1820:	af00      	add	r7, sp, #0
    1822:	6078      	str	r0, [r7, #4]
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    1824:	f001 fb26 	bl	2e74 <vPortEnterCritical>
		uxReturn = pxQueue->uxMessagesWaiting;
    1828:	687b      	ldr	r3, [r7, #4]
    182a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    182c:	60fb      	str	r3, [r7, #12]
	taskEXIT_CRITICAL();
    182e:	f001 fb37 	bl	2ea0 <vPortExitCritical>

	return uxReturn;
    1832:	68fb      	ldr	r3, [r7, #12]
}
    1834:	4618      	mov	r0, r3
    1836:	f107 0710 	add.w	r7, r7, #16
    183a:	46bd      	mov	sp, r7
    183c:	bd80      	pop	{r7, pc}
    183e:	bf00      	nop

00001840 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1840:	b480      	push	{r7}
    1842:	b085      	sub	sp, #20
    1844:	af00      	add	r7, sp, #0
    1846:	6078      	str	r0, [r7, #4]
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    1848:	687b      	ldr	r3, [r7, #4]
    184a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    184c:	60fb      	str	r3, [r7, #12]

	return uxReturn;
    184e:	68fb      	ldr	r3, [r7, #12]
}
    1850:	4618      	mov	r0, r3
    1852:	f107 0714 	add.w	r7, r7, #20
    1856:	46bd      	mov	sp, r7
    1858:	bc80      	pop	{r7}
    185a:	4770      	bx	lr

0000185c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    185c:	b580      	push	{r7, lr}
    185e:	b082      	sub	sp, #8
    1860:	af00      	add	r7, sp, #0
    1862:	6078      	str	r0, [r7, #4]
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
    1864:	6878      	ldr	r0, [r7, #4]
    1866:	f000 f961 	bl	1b2c <vQueueUnregisterQueue>
	vPortFree( pxQueue->pcHead );
    186a:	687b      	ldr	r3, [r7, #4]
    186c:	681b      	ldr	r3, [r3, #0]
    186e:	4618      	mov	r0, r3
    1870:	f001 fa26 	bl	2cc0 <vPortFree>
	vPortFree( pxQueue );
    1874:	6878      	ldr	r0, [r7, #4]
    1876:	f001 fa23 	bl	2cc0 <vPortFree>
}
    187a:	f107 0708 	add.w	r7, r7, #8
    187e:	46bd      	mov	sp, r7
    1880:	bd80      	pop	{r7, pc}
    1882:	bf00      	nop

00001884 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1884:	b580      	push	{r7, lr}
    1886:	b084      	sub	sp, #16
    1888:	af00      	add	r7, sp, #0
    188a:	60f8      	str	r0, [r7, #12]
    188c:	60b9      	str	r1, [r7, #8]
    188e:	607a      	str	r2, [r7, #4]
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1890:	68fb      	ldr	r3, [r7, #12]
    1892:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    1894:	2b00      	cmp	r3, #0
    1896:	d040      	beq.n	191a <prvCopyDataToQueue+0x96>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1898:	687b      	ldr	r3, [r7, #4]
    189a:	2b00      	cmp	r3, #0
    189c:	d11a      	bne.n	18d4 <prvCopyDataToQueue+0x50>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    189e:	68fb      	ldr	r3, [r7, #12]
    18a0:	689a      	ldr	r2, [r3, #8]
    18a2:	68fb      	ldr	r3, [r7, #12]
    18a4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    18a6:	4610      	mov	r0, r2
    18a8:	68b9      	ldr	r1, [r7, #8]
    18aa:	461a      	mov	r2, r3
    18ac:	f001 fb64 	bl	2f78 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    18b0:	68fb      	ldr	r3, [r7, #12]
    18b2:	689a      	ldr	r2, [r3, #8]
    18b4:	68fb      	ldr	r3, [r7, #12]
    18b6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    18b8:	441a      	add	r2, r3
    18ba:	68fb      	ldr	r3, [r7, #12]
    18bc:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    18be:	68fb      	ldr	r3, [r7, #12]
    18c0:	689a      	ldr	r2, [r3, #8]
    18c2:	68fb      	ldr	r3, [r7, #12]
    18c4:	685b      	ldr	r3, [r3, #4]
    18c6:	429a      	cmp	r2, r3
    18c8:	d326      	bcc.n	1918 <prvCopyDataToQueue+0x94>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    18ca:	68fb      	ldr	r3, [r7, #12]
    18cc:	681a      	ldr	r2, [r3, #0]
    18ce:	68fb      	ldr	r3, [r7, #12]
    18d0:	609a      	str	r2, [r3, #8]
    18d2:	e022      	b.n	191a <prvCopyDataToQueue+0x96>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    18d4:	68fb      	ldr	r3, [r7, #12]
    18d6:	68da      	ldr	r2, [r3, #12]
    18d8:	68fb      	ldr	r3, [r7, #12]
    18da:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    18dc:	4610      	mov	r0, r2
    18de:	68b9      	ldr	r1, [r7, #8]
    18e0:	461a      	mov	r2, r3
    18e2:	f001 fb49 	bl	2f78 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    18e6:	68fb      	ldr	r3, [r7, #12]
    18e8:	68da      	ldr	r2, [r3, #12]
    18ea:	68fb      	ldr	r3, [r7, #12]
    18ec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    18ee:	f1c3 0300 	rsb	r3, r3, #0
    18f2:	441a      	add	r2, r3
    18f4:	68fb      	ldr	r3, [r7, #12]
    18f6:	60da      	str	r2, [r3, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    18f8:	68fb      	ldr	r3, [r7, #12]
    18fa:	68da      	ldr	r2, [r3, #12]
    18fc:	68fb      	ldr	r3, [r7, #12]
    18fe:	681b      	ldr	r3, [r3, #0]
    1900:	429a      	cmp	r2, r3
    1902:	d20a      	bcs.n	191a <prvCopyDataToQueue+0x96>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1904:	68fb      	ldr	r3, [r7, #12]
    1906:	685a      	ldr	r2, [r3, #4]
    1908:	68fb      	ldr	r3, [r7, #12]
    190a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    190c:	f1c3 0300 	rsb	r3, r3, #0
    1910:	441a      	add	r2, r3
    1912:	68fb      	ldr	r3, [r7, #12]
    1914:	60da      	str	r2, [r3, #12]
    1916:	e000      	b.n	191a <prvCopyDataToQueue+0x96>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1918:	bf00      	nop
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
    191a:	68fb      	ldr	r3, [r7, #12]
    191c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    191e:	f103 0201 	add.w	r2, r3, #1
    1922:	68fb      	ldr	r3, [r7, #12]
    1924:	639a      	str	r2, [r3, #56]	; 0x38
}
    1926:	f107 0710 	add.w	r7, r7, #16
    192a:	46bd      	mov	sp, r7
    192c:	bd80      	pop	{r7, pc}
    192e:	bf00      	nop

00001930 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1930:	b580      	push	{r7, lr}
    1932:	b082      	sub	sp, #8
    1934:	af00      	add	r7, sp, #0
    1936:	6078      	str	r0, [r7, #4]
    1938:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    193a:	687b      	ldr	r3, [r7, #4]
    193c:	681b      	ldr	r3, [r3, #0]
    193e:	2b00      	cmp	r3, #0
    1940:	d019      	beq.n	1976 <prvCopyDataFromQueue+0x46>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1942:	687b      	ldr	r3, [r7, #4]
    1944:	68da      	ldr	r2, [r3, #12]
    1946:	687b      	ldr	r3, [r7, #4]
    1948:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    194a:	441a      	add	r2, r3
    194c:	687b      	ldr	r3, [r7, #4]
    194e:	60da      	str	r2, [r3, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1950:	687b      	ldr	r3, [r7, #4]
    1952:	68da      	ldr	r2, [r3, #12]
    1954:	687b      	ldr	r3, [r7, #4]
    1956:	685b      	ldr	r3, [r3, #4]
    1958:	429a      	cmp	r2, r3
    195a:	d303      	bcc.n	1964 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    195c:	687b      	ldr	r3, [r7, #4]
    195e:	681a      	ldr	r2, [r3, #0]
    1960:	687b      	ldr	r3, [r7, #4]
    1962:	60da      	str	r2, [r3, #12]
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1964:	687b      	ldr	r3, [r7, #4]
    1966:	68da      	ldr	r2, [r3, #12]
    1968:	687b      	ldr	r3, [r7, #4]
    196a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    196c:	6838      	ldr	r0, [r7, #0]
    196e:	4611      	mov	r1, r2
    1970:	461a      	mov	r2, r3
    1972:	f001 fb01 	bl	2f78 <memcpy>
	}
}
    1976:	f107 0708 	add.w	r7, r7, #8
    197a:	46bd      	mov	sp, r7
    197c:	bd80      	pop	{r7, pc}
    197e:	bf00      	nop

00001980 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1980:	b580      	push	{r7, lr}
    1982:	b082      	sub	sp, #8
    1984:	af00      	add	r7, sp, #0
    1986:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1988:	f001 fa74 	bl	2e74 <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    198c:	e014      	b.n	19b8 <prvUnlockQueue+0x38>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    198e:	687b      	ldr	r3, [r7, #4]
    1990:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    1992:	2b00      	cmp	r3, #0
    1994:	d015      	beq.n	19c2 <prvUnlockQueue+0x42>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1996:	687b      	ldr	r3, [r7, #4]
    1998:	f103 0324 	add.w	r3, r3, #36	; 0x24
    199c:	4618      	mov	r0, r3
    199e:	f000 feff 	bl	27a0 <xTaskRemoveFromEventList>
    19a2:	4603      	mov	r3, r0
    19a4:	2b00      	cmp	r3, #0
    19a6:	d001      	beq.n	19ac <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    19a8:	f000 ffd0 	bl	294c <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    19ac:	687b      	ldr	r3, [r7, #4]
    19ae:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    19b0:	f103 32ff 	add.w	r2, r3, #4294967295
    19b4:	687b      	ldr	r3, [r7, #4]
    19b6:	649a      	str	r2, [r3, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    19b8:	687b      	ldr	r3, [r7, #4]
    19ba:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    19bc:	2b00      	cmp	r3, #0
    19be:	dce6      	bgt.n	198e <prvUnlockQueue+0xe>
    19c0:	e000      	b.n	19c4 <prvUnlockQueue+0x44>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
    19c2:	bf00      	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    19c4:	687b      	ldr	r3, [r7, #4]
    19c6:	f04f 32ff 	mov.w	r2, #4294967295
    19ca:	649a      	str	r2, [r3, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
    19cc:	f001 fa68 	bl	2ea0 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    19d0:	f001 fa50 	bl	2e74 <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    19d4:	e014      	b.n	1a00 <prvUnlockQueue+0x80>
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    19d6:	687b      	ldr	r3, [r7, #4]
    19d8:	691b      	ldr	r3, [r3, #16]
    19da:	2b00      	cmp	r3, #0
    19dc:	d015      	beq.n	1a0a <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    19de:	687b      	ldr	r3, [r7, #4]
    19e0:	f103 0310 	add.w	r3, r3, #16
    19e4:	4618      	mov	r0, r3
    19e6:	f000 fedb 	bl	27a0 <xTaskRemoveFromEventList>
    19ea:	4603      	mov	r3, r0
    19ec:	2b00      	cmp	r3, #0
    19ee:	d001      	beq.n	19f4 <prvUnlockQueue+0x74>
				{
					vTaskMissedYield();
    19f0:	f000 ffac 	bl	294c <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    19f4:	687b      	ldr	r3, [r7, #4]
    19f6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    19f8:	f103 32ff 	add.w	r2, r3, #4294967295
    19fc:	687b      	ldr	r3, [r7, #4]
    19fe:	645a      	str	r2, [r3, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1a00:	687b      	ldr	r3, [r7, #4]
    1a02:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    1a04:	2b00      	cmp	r3, #0
    1a06:	dce6      	bgt.n	19d6 <prvUnlockQueue+0x56>
    1a08:	e000      	b.n	1a0c <prvUnlockQueue+0x8c>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
    1a0a:	bf00      	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1a0c:	687b      	ldr	r3, [r7, #4]
    1a0e:	f04f 32ff 	mov.w	r2, #4294967295
    1a12:	645a      	str	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
    1a14:	f001 fa44 	bl	2ea0 <vPortExitCritical>
}
    1a18:	f107 0708 	add.w	r7, r7, #8
    1a1c:	46bd      	mov	sp, r7
    1a1e:	bd80      	pop	{r7, pc}

00001a20 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    1a20:	b580      	push	{r7, lr}
    1a22:	b084      	sub	sp, #16
    1a24:	af00      	add	r7, sp, #0
    1a26:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1a28:	f001 fa24 	bl	2e74 <vPortEnterCritical>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1a2c:	687b      	ldr	r3, [r7, #4]
    1a2e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    1a30:	2b00      	cmp	r3, #0
    1a32:	bf14      	ite	ne
    1a34:	2300      	movne	r3, #0
    1a36:	2301      	moveq	r3, #1
    1a38:	60fb      	str	r3, [r7, #12]
	taskEXIT_CRITICAL();
    1a3a:	f001 fa31 	bl	2ea0 <vPortExitCritical>

	return xReturn;
    1a3e:	68fb      	ldr	r3, [r7, #12]
}
    1a40:	4618      	mov	r0, r3
    1a42:	f107 0710 	add.w	r7, r7, #16
    1a46:	46bd      	mov	sp, r7
    1a48:	bd80      	pop	{r7, pc}
    1a4a:	bf00      	nop

00001a4c <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1a4c:	b480      	push	{r7}
    1a4e:	b085      	sub	sp, #20
    1a50:	af00      	add	r7, sp, #0
    1a52:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1a54:	687b      	ldr	r3, [r7, #4]
    1a56:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    1a58:	2b00      	cmp	r3, #0
    1a5a:	bf14      	ite	ne
    1a5c:	2300      	movne	r3, #0
    1a5e:	2301      	moveq	r3, #1
    1a60:	60fb      	str	r3, [r7, #12]

	return xReturn;
    1a62:	68fb      	ldr	r3, [r7, #12]
}
    1a64:	4618      	mov	r0, r3
    1a66:	f107 0714 	add.w	r7, r7, #20
    1a6a:	46bd      	mov	sp, r7
    1a6c:	bc80      	pop	{r7}
    1a6e:	4770      	bx	lr

00001a70 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    1a70:	b580      	push	{r7, lr}
    1a72:	b084      	sub	sp, #16
    1a74:	af00      	add	r7, sp, #0
    1a76:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1a78:	f001 f9fc 	bl	2e74 <vPortEnterCritical>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1a7c:	687b      	ldr	r3, [r7, #4]
    1a7e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    1a80:	687b      	ldr	r3, [r7, #4]
    1a82:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    1a84:	429a      	cmp	r2, r3
    1a86:	bf14      	ite	ne
    1a88:	2300      	movne	r3, #0
    1a8a:	2301      	moveq	r3, #1
    1a8c:	60fb      	str	r3, [r7, #12]
	taskEXIT_CRITICAL();
    1a8e:	f001 fa07 	bl	2ea0 <vPortExitCritical>

	return xReturn;
    1a92:	68fb      	ldr	r3, [r7, #12]
}
    1a94:	4618      	mov	r0, r3
    1a96:	f107 0710 	add.w	r7, r7, #16
    1a9a:	46bd      	mov	sp, r7
    1a9c:	bd80      	pop	{r7, pc}
    1a9e:	bf00      	nop

00001aa0 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1aa0:	b480      	push	{r7}
    1aa2:	b085      	sub	sp, #20
    1aa4:	af00      	add	r7, sp, #0
    1aa6:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1aa8:	687b      	ldr	r3, [r7, #4]
    1aaa:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    1aac:	687b      	ldr	r3, [r7, #4]
    1aae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    1ab0:	429a      	cmp	r2, r3
    1ab2:	bf14      	ite	ne
    1ab4:	2300      	movne	r3, #0
    1ab6:	2301      	moveq	r3, #1
    1ab8:	60fb      	str	r3, [r7, #12]

	return xReturn;
    1aba:	68fb      	ldr	r3, [r7, #12]
}
    1abc:	4618      	mov	r0, r3
    1abe:	f107 0714 	add.w	r7, r7, #20
    1ac2:	46bd      	mov	sp, r7
    1ac4:	bc80      	pop	{r7}
    1ac6:	4770      	bx	lr

00001ac8 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if configQUEUE_REGISTRY_SIZE > 0

	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
	{
    1ac8:	b480      	push	{r7}
    1aca:	b085      	sub	sp, #20
    1acc:	af00      	add	r7, sp, #0
    1ace:	6078      	str	r0, [r7, #4]
    1ad0:	6039      	str	r1, [r7, #0]
	unsigned portBASE_TYPE ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = 0; ux < configQUEUE_REGISTRY_SIZE; ux++ )
    1ad2:	f04f 0300 	mov.w	r3, #0
    1ad6:	60fb      	str	r3, [r7, #12]
    1ad8:	e01f      	b.n	1b1a <vQueueAddToRegistry+0x52>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
    1ada:	68fa      	ldr	r2, [r7, #12]
    1adc:	f644 533c 	movw	r3, #19772	; 0x4d3c
    1ae0:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1ae4:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    1ae8:	2b00      	cmp	r3, #0
    1aea:	d112      	bne.n	1b12 <vQueueAddToRegistry+0x4a>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    1aec:	68fa      	ldr	r2, [r7, #12]
    1aee:	f644 533c 	movw	r3, #19772	; 0x4d3c
    1af2:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1af6:	6839      	ldr	r1, [r7, #0]
    1af8:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
    1afc:	68fb      	ldr	r3, [r7, #12]
    1afe:	f644 523c 	movw	r2, #19772	; 0x4d3c
    1b02:	f2c1 0200 	movt	r2, #4096	; 0x1000
    1b06:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1b0a:	4413      	add	r3, r2
    1b0c:	687a      	ldr	r2, [r7, #4]
    1b0e:	605a      	str	r2, [r3, #4]
				break;
    1b10:	e006      	b.n	1b20 <vQueueAddToRegistry+0x58>
	{
	unsigned portBASE_TYPE ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = 0; ux < configQUEUE_REGISTRY_SIZE; ux++ )
    1b12:	68fb      	ldr	r3, [r7, #12]
    1b14:	f103 0301 	add.w	r3, r3, #1
    1b18:	60fb      	str	r3, [r7, #12]
    1b1a:	68fb      	ldr	r3, [r7, #12]
    1b1c:	2b09      	cmp	r3, #9
    1b1e:	d9dc      	bls.n	1ada <vQueueAddToRegistry+0x12>
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
				xQueueRegistry[ ux ].xHandle = xQueue;
				break;
			}
		}
	}
    1b20:	f107 0714 	add.w	r7, r7, #20
    1b24:	46bd      	mov	sp, r7
    1b26:	bc80      	pop	{r7}
    1b28:	4770      	bx	lr
    1b2a:	bf00      	nop

00001b2c <vQueueUnregisterQueue>:
	/*-----------------------------------------------------------*/

#if configQUEUE_REGISTRY_SIZE > 0

	static void vQueueUnregisterQueue( xQueueHandle xQueue )
	{
    1b2c:	b480      	push	{r7}
    1b2e:	b085      	sub	sp, #20
    1b30:	af00      	add	r7, sp, #0
    1b32:	6078      	str	r0, [r7, #4]
	unsigned portBASE_TYPE ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = 0; ux < configQUEUE_REGISTRY_SIZE; ux++ )
    1b34:	f04f 0300 	mov.w	r3, #0
    1b38:	60fb      	str	r3, [r7, #12]
    1b3a:	e019      	b.n	1b70 <vQueueUnregisterQueue+0x44>
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    1b3c:	68fb      	ldr	r3, [r7, #12]
    1b3e:	f644 523c 	movw	r2, #19772	; 0x4d3c
    1b42:	f2c1 0200 	movt	r2, #4096	; 0x1000
    1b46:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1b4a:	4413      	add	r3, r2
    1b4c:	685a      	ldr	r2, [r3, #4]
    1b4e:	687b      	ldr	r3, [r7, #4]
    1b50:	429a      	cmp	r2, r3
    1b52:	d109      	bne.n	1b68 <vQueueUnregisterQueue+0x3c>
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
    1b54:	68fa      	ldr	r2, [r7, #12]
    1b56:	f644 533c 	movw	r3, #19772	; 0x4d3c
    1b5a:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1b5e:	f04f 0100 	mov.w	r1, #0
    1b62:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
				break;
    1b66:	e006      	b.n	1b76 <vQueueUnregisterQueue+0x4a>
	{
	unsigned portBASE_TYPE ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = 0; ux < configQUEUE_REGISTRY_SIZE; ux++ )
    1b68:	68fb      	ldr	r3, [r7, #12]
    1b6a:	f103 0301 	add.w	r3, r3, #1
    1b6e:	60fb      	str	r3, [r7, #12]
    1b70:	68fb      	ldr	r3, [r7, #12]
    1b72:	2b09      	cmp	r3, #9
    1b74:	d9e2      	bls.n	1b3c <vQueueUnregisterQueue+0x10>
				xQueueRegistry[ ux ].pcQueueName = NULL;
				break;
			}
		}

	}
    1b76:	f107 0714 	add.w	r7, r7, #20
    1b7a:	46bd      	mov	sp, r7
    1b7c:	bc80      	pop	{r7}
    1b7e:	4770      	bx	lr

00001b80 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1b80:	b580      	push	{r7, lr}
    1b82:	b08a      	sub	sp, #40	; 0x28
    1b84:	af02      	add	r7, sp, #8
    1b86:	60f8      	str	r0, [r7, #12]
    1b88:	60b9      	str	r1, [r7, #8]
    1b8a:	603b      	str	r3, [r7, #0]
    1b8c:	4613      	mov	r3, r2
    1b8e:	80fb      	strh	r3, [r7, #6]
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1b90:	88fb      	ldrh	r3, [r7, #6]
    1b92:	4618      	mov	r0, r3
    1b94:	6b39      	ldr	r1, [r7, #48]	; 0x30
    1b96:	f000 ff7b 	bl	2a90 <prvAllocateTCBAndStack>
    1b9a:	4603      	mov	r3, r0
    1b9c:	61bb      	str	r3, [r7, #24]

	if( pxNewTCB != NULL )
    1b9e:	69bb      	ldr	r3, [r7, #24]
    1ba0:	2b00      	cmp	r3, #0
    1ba2:	f000 8099 	beq.w	1cd8 <xTaskGenericCreate+0x158>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    1ba6:	69bb      	ldr	r3, [r7, #24]
    1ba8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    1baa:	88fb      	ldrh	r3, [r7, #6]
    1bac:	f103 33ff 	add.w	r3, r3, #4294967295
    1bb0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    1bb4:	4413      	add	r3, r2
    1bb6:	61fb      	str	r3, [r7, #28]
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
    1bb8:	69fb      	ldr	r3, [r7, #28]
    1bba:	f023 0307 	bic.w	r3, r3, #7
    1bbe:	61fb      	str	r3, [r7, #28]
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    1bc0:	88fb      	ldrh	r3, [r7, #6]
    1bc2:	9300      	str	r3, [sp, #0]
    1bc4:	69b8      	ldr	r0, [r7, #24]
    1bc6:	68b9      	ldr	r1, [r7, #8]
    1bc8:	6aba      	ldr	r2, [r7, #40]	; 0x28
    1bca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    1bcc:	f000 fed2 	bl	2974 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1bd0:	69f8      	ldr	r0, [r7, #28]
    1bd2:	68f9      	ldr	r1, [r7, #12]
    1bd4:	683a      	ldr	r2, [r7, #0]
    1bd6:	f001 f8c9 	bl	2d6c <pxPortInitialiseStack>
    1bda:	4603      	mov	r3, r0
    1bdc:	461a      	mov	r2, r3
    1bde:	69bb      	ldr	r3, [r7, #24]
    1be0:	601a      	str	r2, [r3, #0]
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    1be2:	f001 f947 	bl	2e74 <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
    1be6:	f240 03f4 	movw	r3, #244	; 0xf4
    1bea:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1bee:	681b      	ldr	r3, [r3, #0]
    1bf0:	f103 0201 	add.w	r2, r3, #1
    1bf4:	f240 03f4 	movw	r3, #244	; 0xf4
    1bf8:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1bfc:	601a      	str	r2, [r3, #0]
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1bfe:	f240 03f4 	movw	r3, #244	; 0xf4
    1c02:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1c06:	681b      	ldr	r3, [r3, #0]
    1c08:	2b01      	cmp	r3, #1
    1c0a:	d108      	bne.n	1c1e <xTaskGenericCreate+0x9e>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
    1c0c:	f240 0334 	movw	r3, #52	; 0x34
    1c10:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1c14:	69ba      	ldr	r2, [r7, #24]
    1c16:	601a      	str	r2, [r3, #0]

				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    1c18:	f000 fee8 	bl	29ec <prvInitialiseTaskLists>
    1c1c:	e015      	b.n	1c4a <xTaskGenericCreate+0xca>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1c1e:	f240 1304 	movw	r3, #260	; 0x104
    1c22:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1c26:	681b      	ldr	r3, [r3, #0]
    1c28:	2b00      	cmp	r3, #0
    1c2a:	d10e      	bne.n	1c4a <xTaskGenericCreate+0xca>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1c2c:	f240 0334 	movw	r3, #52	; 0x34
    1c30:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1c34:	681b      	ldr	r3, [r3, #0]
    1c36:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1c38:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1c3a:	429a      	cmp	r2, r3
    1c3c:	d805      	bhi.n	1c4a <xTaskGenericCreate+0xca>
					{
						pxCurrentTCB = pxNewTCB;
    1c3e:	f240 0334 	movw	r3, #52	; 0x34
    1c42:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1c46:	69ba      	ldr	r2, [r7, #24]
    1c48:	601a      	str	r2, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1c4a:	69bb      	ldr	r3, [r7, #24]
    1c4c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1c4e:	f240 03fc 	movw	r3, #252	; 0xfc
    1c52:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1c56:	681b      	ldr	r3, [r3, #0]
    1c58:	429a      	cmp	r2, r3
    1c5a:	d906      	bls.n	1c6a <xTaskGenericCreate+0xea>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1c5c:	69bb      	ldr	r3, [r7, #24]
    1c5e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1c60:	f240 03fc 	movw	r3, #252	; 0xfc
    1c64:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1c68:	601a      	str	r2, [r3, #0]
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1c6a:	f240 1318 	movw	r3, #280	; 0x118
    1c6e:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1c72:	681b      	ldr	r3, [r3, #0]
    1c74:	f103 0201 	add.w	r2, r3, #1
    1c78:	f240 1318 	movw	r3, #280	; 0x118
    1c7c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1c80:	601a      	str	r2, [r3, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
    1c82:	69bb      	ldr	r3, [r7, #24]
    1c84:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1c86:	f240 1300 	movw	r3, #256	; 0x100
    1c8a:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1c8e:	681b      	ldr	r3, [r3, #0]
    1c90:	429a      	cmp	r2, r3
    1c92:	d906      	bls.n	1ca2 <xTaskGenericCreate+0x122>
    1c94:	69bb      	ldr	r3, [r7, #24]
    1c96:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1c98:	f240 1300 	movw	r3, #256	; 0x100
    1c9c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1ca0:	601a      	str	r2, [r3, #0]
    1ca2:	69bb      	ldr	r3, [r7, #24]
    1ca4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1ca6:	4613      	mov	r3, r2
    1ca8:	ea4f 0383 	mov.w	r3, r3, lsl #2
    1cac:	4413      	add	r3, r2
    1cae:	ea4f 0383 	mov.w	r3, r3, lsl #2
    1cb2:	461a      	mov	r2, r3
    1cb4:	f240 0338 	movw	r3, #56	; 0x38
    1cb8:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1cbc:	441a      	add	r2, r3
    1cbe:	69bb      	ldr	r3, [r7, #24]
    1cc0:	f103 0304 	add.w	r3, r3, #4
    1cc4:	4610      	mov	r0, r2
    1cc6:	4619      	mov	r1, r3
    1cc8:	f7ff fada 	bl	1280 <vListInsertEnd>

			xReturn = pdPASS;
    1ccc:	f04f 0301 	mov.w	r3, #1
    1cd0:	617b      	str	r3, [r7, #20]
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    1cd2:	f001 f8e5 	bl	2ea0 <vPortExitCritical>
    1cd6:	e002      	b.n	1cde <xTaskGenericCreate+0x15e>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1cd8:	f04f 33ff 	mov.w	r3, #4294967295
    1cdc:	617b      	str	r3, [r7, #20]
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
    1cde:	697b      	ldr	r3, [r7, #20]
    1ce0:	2b01      	cmp	r3, #1
    1ce2:	d117      	bne.n	1d14 <xTaskGenericCreate+0x194>
	{
		if( ( void * ) pxCreatedTask != NULL )
    1ce4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1ce6:	2b00      	cmp	r3, #0
    1ce8:	d002      	beq.n	1cf0 <xTaskGenericCreate+0x170>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1cea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1cec:	69ba      	ldr	r2, [r7, #24]
    1cee:	601a      	str	r2, [r3, #0]
		}

		if( xSchedulerRunning != pdFALSE )
    1cf0:	f240 1304 	movw	r3, #260	; 0x104
    1cf4:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1cf8:	681b      	ldr	r3, [r3, #0]
    1cfa:	2b00      	cmp	r3, #0
    1cfc:	d00a      	beq.n	1d14 <xTaskGenericCreate+0x194>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1cfe:	f240 0334 	movw	r3, #52	; 0x34
    1d02:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1d06:	681b      	ldr	r3, [r3, #0]
    1d08:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1d0a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1d0c:	429a      	cmp	r2, r3
    1d0e:	d201      	bcs.n	1d14 <xTaskGenericCreate+0x194>
			{
				portYIELD_WITHIN_API();
    1d10:	f001 f8a4 	bl	2e5c <vPortYieldFromISR>
			}
		}
	}

	return xReturn;
    1d14:	697b      	ldr	r3, [r7, #20]
}
    1d16:	4618      	mov	r0, r3
    1d18:	f107 0720 	add.w	r7, r7, #32
    1d1c:	46bd      	mov	sp, r7
    1d1e:	bd80      	pop	{r7, pc}

00001d20 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1d20:	b580      	push	{r7, lr}
    1d22:	b086      	sub	sp, #24
    1d24:	af00      	add	r7, sp, #0
    1d26:	6078      	str	r0, [r7, #4]
    1d28:	6039      	str	r1, [r7, #0]
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    1d2a:	f04f 0300 	mov.w	r3, #0
    1d2e:	617b      	str	r3, [r7, #20]

		vTaskSuspendAll();
    1d30:	f000 fadc 	bl	22ec <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1d34:	687b      	ldr	r3, [r7, #4]
    1d36:	681a      	ldr	r2, [r3, #0]
    1d38:	683b      	ldr	r3, [r7, #0]
    1d3a:	4413      	add	r3, r2
    1d3c:	60fb      	str	r3, [r7, #12]

			if( xTickCount < *pxPreviousWakeTime )
    1d3e:	687b      	ldr	r3, [r7, #4]
    1d40:	681a      	ldr	r2, [r3, #0]
    1d42:	f240 03f8 	movw	r3, #248	; 0xf8
    1d46:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1d4a:	681b      	ldr	r3, [r3, #0]
    1d4c:	429a      	cmp	r2, r3
    1d4e:	d910      	bls.n	1d72 <vTaskDelayUntil+0x52>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1d50:	687b      	ldr	r3, [r7, #4]
    1d52:	681a      	ldr	r2, [r3, #0]
    1d54:	68fb      	ldr	r3, [r7, #12]
    1d56:	429a      	cmp	r2, r3
    1d58:	d91c      	bls.n	1d94 <vTaskDelayUntil+0x74>
    1d5a:	f240 03f8 	movw	r3, #248	; 0xf8
    1d5e:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1d62:	681b      	ldr	r3, [r3, #0]
    1d64:	68fa      	ldr	r2, [r7, #12]
    1d66:	429a      	cmp	r2, r3
    1d68:	d916      	bls.n	1d98 <vTaskDelayUntil+0x78>
				{
					xShouldDelay = pdTRUE;
    1d6a:	f04f 0301 	mov.w	r3, #1
    1d6e:	617b      	str	r3, [r7, #20]
    1d70:	e013      	b.n	1d9a <vTaskDelayUntil+0x7a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1d72:	687b      	ldr	r3, [r7, #4]
    1d74:	681a      	ldr	r2, [r3, #0]
    1d76:	68fb      	ldr	r3, [r7, #12]
    1d78:	429a      	cmp	r2, r3
    1d7a:	d807      	bhi.n	1d8c <vTaskDelayUntil+0x6c>
    1d7c:	f240 03f8 	movw	r3, #248	; 0xf8
    1d80:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1d84:	681b      	ldr	r3, [r3, #0]
    1d86:	68fa      	ldr	r2, [r7, #12]
    1d88:	429a      	cmp	r2, r3
    1d8a:	d906      	bls.n	1d9a <vTaskDelayUntil+0x7a>
				{
					xShouldDelay = pdTRUE;
    1d8c:	f04f 0301 	mov.w	r3, #1
    1d90:	617b      	str	r3, [r7, #20]
    1d92:	e002      	b.n	1d9a <vTaskDelayUntil+0x7a>
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
				{
					xShouldDelay = pdTRUE;
    1d94:	bf00      	nop
    1d96:	e000      	b.n	1d9a <vTaskDelayUntil+0x7a>
    1d98:	bf00      	nop
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1d9a:	687b      	ldr	r3, [r7, #4]
    1d9c:	68fa      	ldr	r2, [r7, #12]
    1d9e:	601a      	str	r2, [r3, #0]

			if( xShouldDelay )
    1da0:	697b      	ldr	r3, [r7, #20]
    1da2:	2b00      	cmp	r3, #0
    1da4:	d039      	beq.n	1e1a <vTaskDelayUntil+0xfa>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1da6:	f240 0334 	movw	r3, #52	; 0x34
    1daa:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1dae:	681b      	ldr	r3, [r3, #0]
    1db0:	f103 0304 	add.w	r3, r3, #4
    1db4:	4618      	mov	r0, r3
    1db6:	f7ff fac5 	bl	1344 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1dba:	f240 0334 	movw	r3, #52	; 0x34
    1dbe:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1dc2:	681b      	ldr	r3, [r3, #0]
    1dc4:	68fa      	ldr	r2, [r7, #12]
    1dc6:	605a      	str	r2, [r3, #4]

				if( xTimeToWake < xTickCount )
    1dc8:	f240 03f8 	movw	r3, #248	; 0xf8
    1dcc:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1dd0:	681b      	ldr	r3, [r3, #0]
    1dd2:	68fa      	ldr	r2, [r7, #12]
    1dd4:	429a      	cmp	r2, r3
    1dd6:	d210      	bcs.n	1dfa <vTaskDelayUntil+0xda>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1dd8:	f240 03c8 	movw	r3, #200	; 0xc8
    1ddc:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1de0:	681a      	ldr	r2, [r3, #0]
    1de2:	f240 0334 	movw	r3, #52	; 0x34
    1de6:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1dea:	681b      	ldr	r3, [r3, #0]
    1dec:	f103 0304 	add.w	r3, r3, #4
    1df0:	4610      	mov	r0, r2
    1df2:	4619      	mov	r1, r3
    1df4:	f7ff fa6c 	bl	12d0 <vListInsert>
    1df8:	e00f      	b.n	1e1a <vTaskDelayUntil+0xfa>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1dfa:	f240 03c4 	movw	r3, #196	; 0xc4
    1dfe:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1e02:	681a      	ldr	r2, [r3, #0]
    1e04:	f240 0334 	movw	r3, #52	; 0x34
    1e08:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1e0c:	681b      	ldr	r3, [r3, #0]
    1e0e:	f103 0304 	add.w	r3, r3, #4
    1e12:	4610      	mov	r0, r2
    1e14:	4619      	mov	r1, r3
    1e16:	f7ff fa5b 	bl	12d0 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1e1a:	f000 fa79 	bl	2310 <xTaskResumeAll>
    1e1e:	4603      	mov	r3, r0
    1e20:	613b      	str	r3, [r7, #16]

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    1e22:	693b      	ldr	r3, [r7, #16]
    1e24:	2b00      	cmp	r3, #0
    1e26:	d101      	bne.n	1e2c <vTaskDelayUntil+0x10c>
		{
			portYIELD_WITHIN_API();
    1e28:	f001 f818 	bl	2e5c <vPortYieldFromISR>
		}
	}
    1e2c:	f107 0718 	add.w	r7, r7, #24
    1e30:	46bd      	mov	sp, r7
    1e32:	bd80      	pop	{r7, pc}

00001e34 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1e34:	b580      	push	{r7, lr}
    1e36:	b084      	sub	sp, #16
    1e38:	af00      	add	r7, sp, #0
    1e3a:	6078      	str	r0, [r7, #4]
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1e3c:	f04f 0300 	mov.w	r3, #0
    1e40:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    1e42:	687b      	ldr	r3, [r7, #4]
    1e44:	2b00      	cmp	r3, #0
    1e46:	d047      	beq.n	1ed8 <vTaskDelay+0xa4>
		{
			vTaskSuspendAll();
    1e48:	f000 fa50 	bl	22ec <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1e4c:	f240 03f8 	movw	r3, #248	; 0xf8
    1e50:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1e54:	681a      	ldr	r2, [r3, #0]
    1e56:	687b      	ldr	r3, [r7, #4]
    1e58:	4413      	add	r3, r2
    1e5a:	60bb      	str	r3, [r7, #8]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1e5c:	f240 0334 	movw	r3, #52	; 0x34
    1e60:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1e64:	681b      	ldr	r3, [r3, #0]
    1e66:	f103 0304 	add.w	r3, r3, #4
    1e6a:	4618      	mov	r0, r3
    1e6c:	f7ff fa6a 	bl	1344 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1e70:	f240 0334 	movw	r3, #52	; 0x34
    1e74:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1e78:	681b      	ldr	r3, [r3, #0]
    1e7a:	68ba      	ldr	r2, [r7, #8]
    1e7c:	605a      	str	r2, [r3, #4]

				if( xTimeToWake < xTickCount )
    1e7e:	f240 03f8 	movw	r3, #248	; 0xf8
    1e82:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1e86:	681b      	ldr	r3, [r3, #0]
    1e88:	68ba      	ldr	r2, [r7, #8]
    1e8a:	429a      	cmp	r2, r3
    1e8c:	d210      	bcs.n	1eb0 <vTaskDelay+0x7c>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1e8e:	f240 03c8 	movw	r3, #200	; 0xc8
    1e92:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1e96:	681a      	ldr	r2, [r3, #0]
    1e98:	f240 0334 	movw	r3, #52	; 0x34
    1e9c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1ea0:	681b      	ldr	r3, [r3, #0]
    1ea2:	f103 0304 	add.w	r3, r3, #4
    1ea6:	4610      	mov	r0, r2
    1ea8:	4619      	mov	r1, r3
    1eaa:	f7ff fa11 	bl	12d0 <vListInsert>
    1eae:	e00f      	b.n	1ed0 <vTaskDelay+0x9c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1eb0:	f240 03c4 	movw	r3, #196	; 0xc4
    1eb4:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1eb8:	681a      	ldr	r2, [r3, #0]
    1eba:	f240 0334 	movw	r3, #52	; 0x34
    1ebe:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1ec2:	681b      	ldr	r3, [r3, #0]
    1ec4:	f103 0304 	add.w	r3, r3, #4
    1ec8:	4610      	mov	r0, r2
    1eca:	4619      	mov	r1, r3
    1ecc:	f7ff fa00 	bl	12d0 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    1ed0:	f000 fa1e 	bl	2310 <xTaskResumeAll>
    1ed4:	4603      	mov	r3, r0
    1ed6:	60fb      	str	r3, [r7, #12]
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    1ed8:	68fb      	ldr	r3, [r7, #12]
    1eda:	2b00      	cmp	r3, #0
    1edc:	d101      	bne.n	1ee2 <vTaskDelay+0xae>
		{
			portYIELD_WITHIN_API();
    1ede:	f000 ffbd 	bl	2e5c <vPortYieldFromISR>
		}
	}
    1ee2:	f107 0710 	add.w	r7, r7, #16
    1ee6:	46bd      	mov	sp, r7
    1ee8:	bd80      	pop	{r7, pc}
    1eea:	bf00      	nop

00001eec <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    1eec:	b580      	push	{r7, lr}
    1eee:	b086      	sub	sp, #24
    1ef0:	af00      	add	r7, sp, #0
    1ef2:	6078      	str	r0, [r7, #4]
    1ef4:	6039      	str	r1, [r7, #0]
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentPriority, xYieldRequired = pdFALSE;
    1ef6:	f04f 0300 	mov.w	r3, #0
    1efa:	617b      	str	r3, [r7, #20]

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= configMAX_PRIORITIES )
    1efc:	683b      	ldr	r3, [r7, #0]
    1efe:	2b04      	cmp	r3, #4
    1f00:	d902      	bls.n	1f08 <vTaskPrioritySet+0x1c>
		{
			uxNewPriority = configMAX_PRIORITIES - 1;
    1f02:	f04f 0304 	mov.w	r3, #4
    1f06:	603b      	str	r3, [r7, #0]
		}

		portENTER_CRITICAL();
    1f08:	f000 ffb4 	bl	2e74 <vPortEnterCritical>
		{
			if( pxTask == pxCurrentTCB )
    1f0c:	f240 0334 	movw	r3, #52	; 0x34
    1f10:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1f14:	681b      	ldr	r3, [r3, #0]
    1f16:	687a      	ldr	r2, [r7, #4]
    1f18:	429a      	cmp	r2, r3
    1f1a:	d102      	bne.n	1f22 <vTaskPrioritySet+0x36>
			{
				pxTask = NULL;
    1f1c:	f04f 0300 	mov.w	r3, #0
    1f20:	607b      	str	r3, [r7, #4]
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1f22:	687b      	ldr	r3, [r7, #4]
    1f24:	2b00      	cmp	r3, #0
    1f26:	d105      	bne.n	1f34 <vTaskPrioritySet+0x48>
    1f28:	f240 0334 	movw	r3, #52	; 0x34
    1f2c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1f30:	681b      	ldr	r3, [r3, #0]
    1f32:	e000      	b.n	1f36 <vTaskPrioritySet+0x4a>
    1f34:	687b      	ldr	r3, [r7, #4]
    1f36:	60fb      	str	r3, [r7, #12]
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentPriority = pxTCB->uxPriority;
    1f38:	68fb      	ldr	r3, [r7, #12]
    1f3a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1f3c:	613b      	str	r3, [r7, #16]
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    1f3e:	693a      	ldr	r2, [r7, #16]
    1f40:	683b      	ldr	r3, [r7, #0]
    1f42:	429a      	cmp	r2, r3
    1f44:	d05b      	beq.n	1ffe <vTaskPrioritySet+0x112>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    1f46:	683a      	ldr	r2, [r7, #0]
    1f48:	693b      	ldr	r3, [r7, #16]
    1f4a:	429a      	cmp	r2, r3
    1f4c:	d906      	bls.n	1f5c <vTaskPrioritySet+0x70>
				{
					if( pxTask != NULL )
    1f4e:	687b      	ldr	r3, [r7, #4]
    1f50:	2b00      	cmp	r3, #0
    1f52:	d00a      	beq.n	1f6a <vTaskPrioritySet+0x7e>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    1f54:	f04f 0301 	mov.w	r3, #1
    1f58:	617b      	str	r3, [r7, #20]
    1f5a:	e007      	b.n	1f6c <vTaskPrioritySet+0x80>
					}
				}
				else if( pxTask == NULL )
    1f5c:	687b      	ldr	r3, [r7, #4]
    1f5e:	2b00      	cmp	r3, #0
    1f60:	d104      	bne.n	1f6c <vTaskPrioritySet+0x80>
				{
					/* Setting our own priority down means there may now be another
					task of higher priority that is ready to execute. */
					xYieldRequired = pdTRUE;
    1f62:	f04f 0301 	mov.w	r3, #1
    1f66:	617b      	str	r3, [r7, #20]
    1f68:	e000      	b.n	1f6c <vTaskPrioritySet+0x80>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    1f6a:	bf00      	nop
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    1f6c:	68fb      	ldr	r3, [r7, #12]
    1f6e:	683a      	ldr	r2, [r7, #0]
    1f70:	62da      	str	r2, [r3, #44]	; 0x2c
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    1f72:	683b      	ldr	r3, [r7, #0]
    1f74:	f1c3 0205 	rsb	r2, r3, #5
    1f78:	68fb      	ldr	r3, [r7, #12]
    1f7a:	619a      	str	r2, [r3, #24]

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    1f7c:	68fb      	ldr	r3, [r7, #12]
    1f7e:	6959      	ldr	r1, [r3, #20]
    1f80:	693a      	ldr	r2, [r7, #16]
    1f82:	4613      	mov	r3, r2
    1f84:	ea4f 0383 	mov.w	r3, r3, lsl #2
    1f88:	4413      	add	r3, r2
    1f8a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    1f8e:	461a      	mov	r2, r3
    1f90:	f240 0338 	movw	r3, #56	; 0x38
    1f94:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1f98:	4413      	add	r3, r2
    1f9a:	4299      	cmp	r1, r3
    1f9c:	d12a      	bne.n	1ff4 <vTaskPrioritySet+0x108>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    1f9e:	68fb      	ldr	r3, [r7, #12]
    1fa0:	f103 0304 	add.w	r3, r3, #4
    1fa4:	4618      	mov	r0, r3
    1fa6:	f7ff f9cd 	bl	1344 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1faa:	68fb      	ldr	r3, [r7, #12]
    1fac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1fae:	f240 1300 	movw	r3, #256	; 0x100
    1fb2:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1fb6:	681b      	ldr	r3, [r3, #0]
    1fb8:	429a      	cmp	r2, r3
    1fba:	d906      	bls.n	1fca <vTaskPrioritySet+0xde>
    1fbc:	68fb      	ldr	r3, [r7, #12]
    1fbe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1fc0:	f240 1300 	movw	r3, #256	; 0x100
    1fc4:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1fc8:	601a      	str	r2, [r3, #0]
    1fca:	68fb      	ldr	r3, [r7, #12]
    1fcc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1fce:	4613      	mov	r3, r2
    1fd0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    1fd4:	4413      	add	r3, r2
    1fd6:	ea4f 0383 	mov.w	r3, r3, lsl #2
    1fda:	461a      	mov	r2, r3
    1fdc:	f240 0338 	movw	r3, #56	; 0x38
    1fe0:	f2c1 0300 	movt	r3, #4096	; 0x1000
    1fe4:	441a      	add	r2, r3
    1fe6:	68fb      	ldr	r3, [r7, #12]
    1fe8:	f103 0304 	add.w	r3, r3, #4
    1fec:	4610      	mov	r0, r2
    1fee:	4619      	mov	r1, r3
    1ff0:	f7ff f946 	bl	1280 <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
    1ff4:	697b      	ldr	r3, [r7, #20]
    1ff6:	2b01      	cmp	r3, #1
    1ff8:	d101      	bne.n	1ffe <vTaskPrioritySet+0x112>
				{
					portYIELD_WITHIN_API();
    1ffa:	f000 ff2f 	bl	2e5c <vPortYieldFromISR>
				}
			}
		}
		portEXIT_CRITICAL();
    1ffe:	f000 ff4f 	bl	2ea0 <vPortExitCritical>
	}
    2002:	f107 0718 	add.w	r7, r7, #24
    2006:	46bd      	mov	sp, r7
    2008:	bd80      	pop	{r7, pc}
    200a:	bf00      	nop

0000200c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    200c:	b580      	push	{r7, lr}
    200e:	b084      	sub	sp, #16
    2010:	af00      	add	r7, sp, #0
    2012:	6078      	str	r0, [r7, #4]
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    2014:	f000 ff2e 	bl	2e74 <vPortEnterCritical>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    2018:	f240 0334 	movw	r3, #52	; 0x34
    201c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2020:	681b      	ldr	r3, [r3, #0]
    2022:	687a      	ldr	r2, [r7, #4]
    2024:	429a      	cmp	r2, r3
    2026:	d102      	bne.n	202e <vTaskSuspend+0x22>
			{
				pxTaskToSuspend = NULL;
    2028:	f04f 0300 	mov.w	r3, #0
    202c:	607b      	str	r3, [r7, #4]
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    202e:	687b      	ldr	r3, [r7, #4]
    2030:	2b00      	cmp	r3, #0
    2032:	d105      	bne.n	2040 <vTaskSuspend+0x34>
    2034:	f240 0334 	movw	r3, #52	; 0x34
    2038:	f2c1 0300 	movt	r3, #4096	; 0x1000
    203c:	681b      	ldr	r3, [r3, #0]
    203e:	e000      	b.n	2042 <vTaskSuspend+0x36>
    2040:	687b      	ldr	r3, [r7, #4]
    2042:	60fb      	str	r3, [r7, #12]

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2044:	68fb      	ldr	r3, [r7, #12]
    2046:	f103 0304 	add.w	r3, r3, #4
    204a:	4618      	mov	r0, r3
    204c:	f7ff f97a 	bl	1344 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    2050:	68fb      	ldr	r3, [r7, #12]
    2052:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2054:	2b00      	cmp	r3, #0
    2056:	d005      	beq.n	2064 <vTaskSuspend+0x58>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    2058:	68fb      	ldr	r3, [r7, #12]
    205a:	f103 0318 	add.w	r3, r3, #24
    205e:	4618      	mov	r0, r3
    2060:	f7ff f970 	bl	1344 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    2064:	68fb      	ldr	r3, [r7, #12]
    2066:	f103 0304 	add.w	r3, r3, #4
    206a:	f240 00e0 	movw	r0, #224	; 0xe0
    206e:	f2c1 0000 	movt	r0, #4096	; 0x1000
    2072:	4619      	mov	r1, r3
    2074:	f7ff f904 	bl	1280 <vListInsertEnd>
		}
		portEXIT_CRITICAL();
    2078:	f000 ff12 	bl	2ea0 <vPortExitCritical>

		/* We may have just suspended the current task. */
		if( ( void * ) pxTaskToSuspend == NULL )
    207c:	687b      	ldr	r3, [r7, #4]
    207e:	2b00      	cmp	r3, #0
    2080:	d101      	bne.n	2086 <vTaskSuspend+0x7a>
		{
			portYIELD_WITHIN_API();
    2082:	f000 feeb 	bl	2e5c <vPortYieldFromISR>
		}
	}
    2086:	f107 0710 	add.w	r7, r7, #16
    208a:	46bd      	mov	sp, r7
    208c:	bd80      	pop	{r7, pc}
    208e:	bf00      	nop

00002090 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    2090:	b480      	push	{r7}
    2092:	b085      	sub	sp, #20
    2094:	af00      	add	r7, sp, #0
    2096:	6078      	str	r0, [r7, #4]
	portBASE_TYPE xReturn = pdFALSE;
    2098:	f04f 0300 	mov.w	r3, #0
    209c:	60bb      	str	r3, [r7, #8]
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    209e:	687b      	ldr	r3, [r7, #4]
    20a0:	60fb      	str	r3, [r7, #12]

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    20a2:	68fb      	ldr	r3, [r7, #12]
    20a4:	695a      	ldr	r2, [r3, #20]
    20a6:	f240 03e0 	movw	r3, #224	; 0xe0
    20aa:	f2c1 0300 	movt	r3, #4096	; 0x1000
    20ae:	429a      	cmp	r2, r3
    20b0:	d10e      	bne.n	20d0 <xTaskIsTaskSuspended+0x40>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    20b2:	68fb      	ldr	r3, [r7, #12]
    20b4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    20b6:	f240 03cc 	movw	r3, #204	; 0xcc
    20ba:	f2c1 0300 	movt	r3, #4096	; 0x1000
    20be:	429a      	cmp	r2, r3
    20c0:	d006      	beq.n	20d0 <xTaskIsTaskSuspended+0x40>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    20c2:	68fb      	ldr	r3, [r7, #12]
    20c4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    20c6:	2b00      	cmp	r3, #0
    20c8:	d102      	bne.n	20d0 <xTaskIsTaskSuspended+0x40>
				{
					xReturn = pdTRUE;
    20ca:	f04f 0301 	mov.w	r3, #1
    20ce:	60bb      	str	r3, [r7, #8]
				}
			}
		}

		return xReturn;
    20d0:	68bb      	ldr	r3, [r7, #8]
	}
    20d2:	4618      	mov	r0, r3
    20d4:	f107 0714 	add.w	r7, r7, #20
    20d8:	46bd      	mov	sp, r7
    20da:	bc80      	pop	{r7}
    20dc:	4770      	bx	lr
    20de:	bf00      	nop

000020e0 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    20e0:	b580      	push	{r7, lr}
    20e2:	b084      	sub	sp, #16
    20e4:	af00      	add	r7, sp, #0
    20e6:	6078      	str	r0, [r7, #4]
	tskTCB *pxTCB;

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    20e8:	687b      	ldr	r3, [r7, #4]
    20ea:	60fb      	str	r3, [r7, #12]

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    20ec:	68fb      	ldr	r3, [r7, #12]
    20ee:	2b00      	cmp	r3, #0
    20f0:	d048      	beq.n	2184 <vTaskResume+0xa4>
    20f2:	f240 0334 	movw	r3, #52	; 0x34
    20f6:	f2c1 0300 	movt	r3, #4096	; 0x1000
    20fa:	681b      	ldr	r3, [r3, #0]
    20fc:	68fa      	ldr	r2, [r7, #12]
    20fe:	429a      	cmp	r2, r3
    2100:	d040      	beq.n	2184 <vTaskResume+0xa4>
		{
			portENTER_CRITICAL();
    2102:	f000 feb7 	bl	2e74 <vPortEnterCritical>
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    2106:	68f8      	ldr	r0, [r7, #12]
    2108:	f7ff ffc2 	bl	2090 <xTaskIsTaskSuspended>
    210c:	4603      	mov	r3, r0
    210e:	2b01      	cmp	r3, #1
    2110:	d136      	bne.n	2180 <vTaskResume+0xa0>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    2112:	68fb      	ldr	r3, [r7, #12]
    2114:	f103 0304 	add.w	r3, r3, #4
    2118:	4618      	mov	r0, r3
    211a:	f7ff f913 	bl	1344 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    211e:	68fb      	ldr	r3, [r7, #12]
    2120:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2122:	f240 1300 	movw	r3, #256	; 0x100
    2126:	f2c1 0300 	movt	r3, #4096	; 0x1000
    212a:	681b      	ldr	r3, [r3, #0]
    212c:	429a      	cmp	r2, r3
    212e:	d906      	bls.n	213e <vTaskResume+0x5e>
    2130:	68fb      	ldr	r3, [r7, #12]
    2132:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2134:	f240 1300 	movw	r3, #256	; 0x100
    2138:	f2c1 0300 	movt	r3, #4096	; 0x1000
    213c:	601a      	str	r2, [r3, #0]
    213e:	68fb      	ldr	r3, [r7, #12]
    2140:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2142:	4613      	mov	r3, r2
    2144:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2148:	4413      	add	r3, r2
    214a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    214e:	461a      	mov	r2, r3
    2150:	f240 0338 	movw	r3, #56	; 0x38
    2154:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2158:	441a      	add	r2, r3
    215a:	68fb      	ldr	r3, [r7, #12]
    215c:	f103 0304 	add.w	r3, r3, #4
    2160:	4610      	mov	r0, r2
    2162:	4619      	mov	r1, r3
    2164:	f7ff f88c 	bl	1280 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2168:	68fb      	ldr	r3, [r7, #12]
    216a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    216c:	f240 0334 	movw	r3, #52	; 0x34
    2170:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2174:	681b      	ldr	r3, [r3, #0]
    2176:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2178:	429a      	cmp	r2, r3
    217a:	d301      	bcc.n	2180 <vTaskResume+0xa0>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    217c:	f000 fe6e 	bl	2e5c <vPortYieldFromISR>
					}
				}
			}
			portEXIT_CRITICAL();
    2180:	f000 fe8e 	bl	2ea0 <vPortExitCritical>
		}
	}
    2184:	f107 0710 	add.w	r7, r7, #16
    2188:	46bd      	mov	sp, r7
    218a:	bd80      	pop	{r7, pc}

0000218c <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    218c:	b580      	push	{r7, lr}
    218e:	b084      	sub	sp, #16
    2190:	af00      	add	r7, sp, #0
    2192:	6078      	str	r0, [r7, #4]
	portBASE_TYPE xYieldRequired = pdFALSE;
    2194:	f04f 0300 	mov.w	r3, #0
    2198:	60bb      	str	r3, [r7, #8]
	tskTCB *pxTCB;

		pxTCB = ( tskTCB * ) pxTaskToResume;
    219a:	687b      	ldr	r3, [r7, #4]
    219c:	60fb      	str	r3, [r7, #12]

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    219e:	68f8      	ldr	r0, [r7, #12]
    21a0:	f7ff ff76 	bl	2090 <xTaskIsTaskSuspended>
    21a4:	4603      	mov	r3, r0
    21a6:	2b01      	cmp	r3, #1
    21a8:	d149      	bne.n	223e <xTaskResumeFromISR+0xb2>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    21aa:	f240 1308 	movw	r3, #264	; 0x108
    21ae:	f2c1 0300 	movt	r3, #4096	; 0x1000
    21b2:	681b      	ldr	r3, [r3, #0]
    21b4:	2b00      	cmp	r3, #0
    21b6:	d138      	bne.n	222a <xTaskResumeFromISR+0x9e>
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    21b8:	68fb      	ldr	r3, [r7, #12]
    21ba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    21bc:	f240 0334 	movw	r3, #52	; 0x34
    21c0:	f2c1 0300 	movt	r3, #4096	; 0x1000
    21c4:	681b      	ldr	r3, [r3, #0]
    21c6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    21c8:	429a      	cmp	r2, r3
    21ca:	bf34      	ite	cc
    21cc:	2300      	movcc	r3, #0
    21ce:	2301      	movcs	r3, #1
    21d0:	60bb      	str	r3, [r7, #8]
				vListRemove(  &( pxTCB->xGenericListItem ) );
    21d2:	68fb      	ldr	r3, [r7, #12]
    21d4:	f103 0304 	add.w	r3, r3, #4
    21d8:	4618      	mov	r0, r3
    21da:	f7ff f8b3 	bl	1344 <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    21de:	68fb      	ldr	r3, [r7, #12]
    21e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    21e2:	f240 1300 	movw	r3, #256	; 0x100
    21e6:	f2c1 0300 	movt	r3, #4096	; 0x1000
    21ea:	681b      	ldr	r3, [r3, #0]
    21ec:	429a      	cmp	r2, r3
    21ee:	d906      	bls.n	21fe <xTaskResumeFromISR+0x72>
    21f0:	68fb      	ldr	r3, [r7, #12]
    21f2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    21f4:	f240 1300 	movw	r3, #256	; 0x100
    21f8:	f2c1 0300 	movt	r3, #4096	; 0x1000
    21fc:	601a      	str	r2, [r3, #0]
    21fe:	68fb      	ldr	r3, [r7, #12]
    2200:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2202:	4613      	mov	r3, r2
    2204:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2208:	4413      	add	r3, r2
    220a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    220e:	461a      	mov	r2, r3
    2210:	f240 0338 	movw	r3, #56	; 0x38
    2214:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2218:	441a      	add	r2, r3
    221a:	68fb      	ldr	r3, [r7, #12]
    221c:	f103 0304 	add.w	r3, r3, #4
    2220:	4610      	mov	r0, r2
    2222:	4619      	mov	r1, r3
    2224:	f7ff f82c 	bl	1280 <vListInsertEnd>
    2228:	e009      	b.n	223e <xTaskResumeFromISR+0xb2>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    222a:	68fb      	ldr	r3, [r7, #12]
    222c:	f103 0318 	add.w	r3, r3, #24
    2230:	f240 00cc 	movw	r0, #204	; 0xcc
    2234:	f2c1 0000 	movt	r0, #4096	; 0x1000
    2238:	4619      	mov	r1, r3
    223a:	f7ff f821 	bl	1280 <vListInsertEnd>
			}
		}

		return xYieldRequired;
    223e:	68bb      	ldr	r3, [r7, #8]
	}
    2240:	4618      	mov	r0, r3
    2242:	f107 0710 	add.w	r7, r7, #16
    2246:	46bd      	mov	sp, r7
    2248:	bd80      	pop	{r7, pc}
    224a:	bf00      	nop

0000224c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    224c:	b580      	push	{r7, lr}
    224e:	b086      	sub	sp, #24
    2250:	af04      	add	r7, sp, #16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    2252:	f243 2360 	movw	r3, #12896	; 0x3260
    2256:	f2c0 0300 	movt	r3, #0
    225a:	f04f 0200 	mov.w	r2, #0
    225e:	9200      	str	r2, [sp, #0]
    2260:	f04f 0200 	mov.w	r2, #0
    2264:	9201      	str	r2, [sp, #4]
    2266:	f04f 0200 	mov.w	r2, #0
    226a:	9202      	str	r2, [sp, #8]
    226c:	f04f 0200 	mov.w	r2, #0
    2270:	9203      	str	r2, [sp, #12]
    2272:	f642 1065 	movw	r0, #10597	; 0x2965
    2276:	f2c0 0000 	movt	r0, #0
    227a:	4619      	mov	r1, r3
    227c:	f04f 0250 	mov.w	r2, #80	; 0x50
    2280:	f04f 0300 	mov.w	r3, #0
    2284:	f7ff fc7c 	bl	1b80 <xTaskGenericCreate>
    2288:	4603      	mov	r3, r0
    228a:	607b      	str	r3, [r7, #4]

	if( xReturn == pdPASS )
    228c:	687b      	ldr	r3, [r7, #4]
    228e:	2b01      	cmp	r3, #1
    2290:	d115      	bne.n	22be <vTaskStartScheduler+0x72>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2292:	f04f 0028 	mov.w	r0, #40	; 0x28
    2296:	f380 8811 	msr	BASEPRI, r0

		xSchedulerRunning = pdTRUE;
    229a:	f240 1304 	movw	r3, #260	; 0x104
    229e:	f2c1 0300 	movt	r3, #4096	; 0x1000
    22a2:	f04f 0201 	mov.w	r2, #1
    22a6:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0;
    22a8:	f240 03f8 	movw	r3, #248	; 0xf8
    22ac:	f2c1 0300 	movt	r3, #4096	; 0x1000
    22b0:	f04f 0200 	mov.w	r2, #0
    22b4:	601a      	str	r2, [r3, #0]

		/* If configGENERATE_RUN_TIME_STATS is defined then the following
		macro must be defined to configure the timer/counter used to generate
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
    22b6:	f7fe f93b 	bl	530 <vConfigureTimerForRunTimeStats>

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    22ba:	f000 fd9f 	bl	2dfc <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    22be:	f107 0708 	add.w	r7, r7, #8
    22c2:	46bd      	mov	sp, r7
    22c4:	bd80      	pop	{r7, pc}
    22c6:	bf00      	nop

000022c8 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    22c8:	b580      	push	{r7, lr}
    22ca:	af00      	add	r7, sp, #0
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    22cc:	f04f 0028 	mov.w	r0, #40	; 0x28
    22d0:	f380 8811 	msr	BASEPRI, r0
	xSchedulerRunning = pdFALSE;
    22d4:	f240 1304 	movw	r3, #260	; 0x104
    22d8:	f2c1 0300 	movt	r3, #4096	; 0x1000
    22dc:	f04f 0200 	mov.w	r2, #0
    22e0:	601a      	str	r2, [r3, #0]
	vPortEndScheduler();
    22e2:	f000 fdb5 	bl	2e50 <vPortEndScheduler>
}
    22e6:	46bd      	mov	sp, r7
    22e8:	bd80      	pop	{r7, pc}
    22ea:	bf00      	nop

000022ec <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    22ec:	b480      	push	{r7}
    22ee:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    22f0:	f240 1308 	movw	r3, #264	; 0x108
    22f4:	f2c1 0300 	movt	r3, #4096	; 0x1000
    22f8:	681b      	ldr	r3, [r3, #0]
    22fa:	f103 0201 	add.w	r2, r3, #1
    22fe:	f240 1308 	movw	r3, #264	; 0x108
    2302:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2306:	601a      	str	r2, [r3, #0]
}
    2308:	46bd      	mov	sp, r7
    230a:	bc80      	pop	{r7}
    230c:	4770      	bx	lr
    230e:	bf00      	nop

00002310 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2310:	b590      	push	{r4, r7, lr}
    2312:	b083      	sub	sp, #12
    2314:	af00      	add	r7, sp, #0
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2316:	f04f 0300 	mov.w	r3, #0
    231a:	603b      	str	r3, [r7, #0]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    231c:	f000 fdaa 	bl	2e74 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
    2320:	f240 1308 	movw	r3, #264	; 0x108
    2324:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2328:	681b      	ldr	r3, [r3, #0]
    232a:	f103 32ff 	add.w	r2, r3, #4294967295
    232e:	f240 1308 	movw	r3, #264	; 0x108
    2332:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2336:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2338:	f240 1308 	movw	r3, #264	; 0x108
    233c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2340:	681b      	ldr	r3, [r3, #0]
    2342:	2b00      	cmp	r3, #0
    2344:	f040 808c 	bne.w	2460 <xTaskResumeAll+0x150>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    2348:	f240 03f4 	movw	r3, #244	; 0xf4
    234c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2350:	681b      	ldr	r3, [r3, #0]
    2352:	2b00      	cmp	r3, #0
    2354:	f000 8084 	beq.w	2460 <xTaskResumeAll+0x150>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    2358:	f04f 0300 	mov.w	r3, #0
    235c:	607b      	str	r3, [r7, #4]

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    235e:	e036      	b.n	23ce <xTaskResumeAll+0xbe>
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    2360:	f104 0318 	add.w	r3, r4, #24
    2364:	4618      	mov	r0, r3
    2366:	f7fe ffed 	bl	1344 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    236a:	f104 0304 	add.w	r3, r4, #4
    236e:	4618      	mov	r0, r3
    2370:	f7fe ffe8 	bl	1344 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2374:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    2376:	f240 1300 	movw	r3, #256	; 0x100
    237a:	f2c1 0300 	movt	r3, #4096	; 0x1000
    237e:	681b      	ldr	r3, [r3, #0]
    2380:	429a      	cmp	r2, r3
    2382:	d905      	bls.n	2390 <xTaskResumeAll+0x80>
    2384:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    2386:	f240 1300 	movw	r3, #256	; 0x100
    238a:	f2c1 0300 	movt	r3, #4096	; 0x1000
    238e:	601a      	str	r2, [r3, #0]
    2390:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    2392:	4613      	mov	r3, r2
    2394:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2398:	4413      	add	r3, r2
    239a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    239e:	461a      	mov	r2, r3
    23a0:	f240 0338 	movw	r3, #56	; 0x38
    23a4:	f2c1 0300 	movt	r3, #4096	; 0x1000
    23a8:	441a      	add	r2, r3
    23aa:	f104 0304 	add.w	r3, r4, #4
    23ae:	4610      	mov	r0, r2
    23b0:	4619      	mov	r1, r3
    23b2:	f7fe ff65 	bl	1280 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    23b6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    23b8:	f240 0334 	movw	r3, #52	; 0x34
    23bc:	f2c1 0300 	movt	r3, #4096	; 0x1000
    23c0:	681b      	ldr	r3, [r3, #0]
    23c2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    23c4:	429a      	cmp	r2, r3
    23c6:	d302      	bcc.n	23ce <xTaskResumeAll+0xbe>
					{
						xYieldRequired = pdTRUE;
    23c8:	f04f 0301 	mov.w	r3, #1
    23cc:	607b      	str	r3, [r7, #4]
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    23ce:	f240 03cc 	movw	r3, #204	; 0xcc
    23d2:	f2c1 0300 	movt	r3, #4096	; 0x1000
    23d6:	681b      	ldr	r3, [r3, #0]
    23d8:	2b00      	cmp	r3, #0
    23da:	d006      	beq.n	23ea <xTaskResumeAll+0xda>
    23dc:	f240 03cc 	movw	r3, #204	; 0xcc
    23e0:	f2c1 0300 	movt	r3, #4096	; 0x1000
    23e4:	68db      	ldr	r3, [r3, #12]
    23e6:	68db      	ldr	r3, [r3, #12]
    23e8:	e001      	b.n	23ee <xTaskResumeAll+0xde>
    23ea:	f04f 0300 	mov.w	r3, #0
    23ee:	461c      	mov	r4, r3
    23f0:	2c00      	cmp	r4, #0
    23f2:	d1b5      	bne.n	2360 <xTaskResumeAll+0x50>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    23f4:	f240 130c 	movw	r3, #268	; 0x10c
    23f8:	f2c1 0300 	movt	r3, #4096	; 0x1000
    23fc:	681b      	ldr	r3, [r3, #0]
    23fe:	2b00      	cmp	r3, #0
    2400:	d018      	beq.n	2434 <xTaskResumeAll+0x124>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    2402:	e00d      	b.n	2420 <xTaskResumeAll+0x110>
					{
						vTaskIncrementTick();
    2404:	f000 f854 	bl	24b0 <vTaskIncrementTick>
						--uxMissedTicks;
    2408:	f240 130c 	movw	r3, #268	; 0x10c
    240c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2410:	681b      	ldr	r3, [r3, #0]
    2412:	f103 32ff 	add.w	r2, r3, #4294967295
    2416:	f240 130c 	movw	r3, #268	; 0x10c
    241a:	f2c1 0300 	movt	r3, #4096	; 0x1000
    241e:	601a      	str	r2, [r3, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    2420:	f240 130c 	movw	r3, #268	; 0x10c
    2424:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2428:	681b      	ldr	r3, [r3, #0]
    242a:	2b00      	cmp	r3, #0
    242c:	d1ea      	bne.n	2404 <xTaskResumeAll+0xf4>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    242e:	f04f 0301 	mov.w	r3, #1
    2432:	607b      	str	r3, [r7, #4]
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2434:	687b      	ldr	r3, [r7, #4]
    2436:	2b01      	cmp	r3, #1
    2438:	d006      	beq.n	2448 <xTaskResumeAll+0x138>
    243a:	f240 1310 	movw	r3, #272	; 0x110
    243e:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2442:	681b      	ldr	r3, [r3, #0]
    2444:	2b01      	cmp	r3, #1
    2446:	d10b      	bne.n	2460 <xTaskResumeAll+0x150>
				{
					xAlreadyYielded = pdTRUE;
    2448:	f04f 0301 	mov.w	r3, #1
    244c:	603b      	str	r3, [r7, #0]
					xMissedYield = pdFALSE;
    244e:	f240 1310 	movw	r3, #272	; 0x110
    2452:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2456:	f04f 0200 	mov.w	r2, #0
    245a:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
    245c:	f000 fcfe 	bl	2e5c <vPortYieldFromISR>
				}
			}
		}
	}
	portEXIT_CRITICAL();
    2460:	f000 fd1e 	bl	2ea0 <vPortExitCritical>

	return xAlreadyYielded;
    2464:	683b      	ldr	r3, [r7, #0]
}
    2466:	4618      	mov	r0, r3
    2468:	f107 070c 	add.w	r7, r7, #12
    246c:	46bd      	mov	sp, r7
    246e:	bd90      	pop	{r4, r7, pc}

00002470 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    2470:	b580      	push	{r7, lr}
    2472:	b082      	sub	sp, #8
    2474:	af00      	add	r7, sp, #0
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    2476:	f000 fcfd 	bl	2e74 <vPortEnterCritical>
	{
		xTicks = xTickCount;
    247a:	f240 03f8 	movw	r3, #248	; 0xf8
    247e:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2482:	681b      	ldr	r3, [r3, #0]
    2484:	607b      	str	r3, [r7, #4]
	}
	portEXIT_CRITICAL();
    2486:	f000 fd0b 	bl	2ea0 <vPortExitCritical>

	return xTicks;
    248a:	687b      	ldr	r3, [r7, #4]
}
    248c:	4618      	mov	r0, r3
    248e:	f107 0708 	add.w	r7, r7, #8
    2492:	46bd      	mov	sp, r7
    2494:	bd80      	pop	{r7, pc}
    2496:	bf00      	nop

00002498 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    2498:	b480      	push	{r7}
    249a:	af00      	add	r7, sp, #0
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    249c:	f240 03f4 	movw	r3, #244	; 0xf4
    24a0:	f2c1 0300 	movt	r3, #4096	; 0x1000
    24a4:	681b      	ldr	r3, [r3, #0]
}
    24a6:	4618      	mov	r0, r3
    24a8:	46bd      	mov	sp, r7
    24aa:	bc80      	pop	{r7}
    24ac:	4770      	bx	lr
    24ae:	bf00      	nop

000024b0 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    24b0:	b590      	push	{r4, r7, lr}
    24b2:	b083      	sub	sp, #12
    24b4:	af00      	add	r7, sp, #0
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    24b6:	f240 1308 	movw	r3, #264	; 0x108
    24ba:	f2c1 0300 	movt	r3, #4096	; 0x1000
    24be:	681b      	ldr	r3, [r3, #0]
    24c0:	2b00      	cmp	r3, #0
    24c2:	f040 8082 	bne.w	25ca <vTaskIncrementTick+0x11a>
	{
		++xTickCount;
    24c6:	f240 03f8 	movw	r3, #248	; 0xf8
    24ca:	f2c1 0300 	movt	r3, #4096	; 0x1000
    24ce:	681b      	ldr	r3, [r3, #0]
    24d0:	f103 0201 	add.w	r2, r3, #1
    24d4:	f240 03f8 	movw	r3, #248	; 0xf8
    24d8:	f2c1 0300 	movt	r3, #4096	; 0x1000
    24dc:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0 )
    24de:	f240 03f8 	movw	r3, #248	; 0xf8
    24e2:	f2c1 0300 	movt	r3, #4096	; 0x1000
    24e6:	681b      	ldr	r3, [r3, #0]
    24e8:	2b00      	cmp	r3, #0
    24ea:	d158      	bne.n	259e <vTaskIncrementTick+0xee>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    24ec:	f240 03c4 	movw	r3, #196	; 0xc4
    24f0:	f2c1 0300 	movt	r3, #4096	; 0x1000
    24f4:	681b      	ldr	r3, [r3, #0]
    24f6:	607b      	str	r3, [r7, #4]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    24f8:	f240 03c8 	movw	r3, #200	; 0xc8
    24fc:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2500:	681a      	ldr	r2, [r3, #0]
    2502:	f240 03c4 	movw	r3, #196	; 0xc4
    2506:	f2c1 0300 	movt	r3, #4096	; 0x1000
    250a:	601a      	str	r2, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
    250c:	f240 03c8 	movw	r3, #200	; 0xc8
    2510:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2514:	687a      	ldr	r2, [r7, #4]
    2516:	601a      	str	r2, [r3, #0]
			xNumOfOverflows++;
    2518:	f240 1314 	movw	r3, #276	; 0x114
    251c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2520:	681b      	ldr	r3, [r3, #0]
    2522:	f103 0201 	add.w	r2, r3, #1
    2526:	f240 1314 	movw	r3, #276	; 0x114
    252a:	f2c1 0300 	movt	r3, #4096	; 0x1000
    252e:	601a      	str	r2, [r3, #0]
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2530:	e035      	b.n	259e <vTaskIncrementTick+0xee>
    2532:	6862      	ldr	r2, [r4, #4]
    2534:	f240 03f8 	movw	r3, #248	; 0xf8
    2538:	f2c1 0300 	movt	r3, #4096	; 0x1000
    253c:	681b      	ldr	r3, [r3, #0]
    253e:	429a      	cmp	r2, r3
    2540:	d851      	bhi.n	25e6 <vTaskIncrementTick+0x136>
    2542:	f104 0304 	add.w	r3, r4, #4
    2546:	4618      	mov	r0, r3
    2548:	f7fe fefc 	bl	1344 <vListRemove>
    254c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    254e:	2b00      	cmp	r3, #0
    2550:	d004      	beq.n	255c <vTaskIncrementTick+0xac>
    2552:	f104 0318 	add.w	r3, r4, #24
    2556:	4618      	mov	r0, r3
    2558:	f7fe fef4 	bl	1344 <vListRemove>
    255c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    255e:	f240 1300 	movw	r3, #256	; 0x100
    2562:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2566:	681b      	ldr	r3, [r3, #0]
    2568:	429a      	cmp	r2, r3
    256a:	d905      	bls.n	2578 <vTaskIncrementTick+0xc8>
    256c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    256e:	f240 1300 	movw	r3, #256	; 0x100
    2572:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2576:	601a      	str	r2, [r3, #0]
    2578:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    257a:	4613      	mov	r3, r2
    257c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2580:	4413      	add	r3, r2
    2582:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2586:	461a      	mov	r2, r3
    2588:	f240 0338 	movw	r3, #56	; 0x38
    258c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2590:	441a      	add	r2, r3
    2592:	f104 0304 	add.w	r3, r4, #4
    2596:	4610      	mov	r0, r2
    2598:	4619      	mov	r1, r3
    259a:	f7fe fe71 	bl	1280 <vListInsertEnd>
    259e:	f240 03c4 	movw	r3, #196	; 0xc4
    25a2:	f2c1 0300 	movt	r3, #4096	; 0x1000
    25a6:	681b      	ldr	r3, [r3, #0]
    25a8:	681b      	ldr	r3, [r3, #0]
    25aa:	2b00      	cmp	r3, #0
    25ac:	d007      	beq.n	25be <vTaskIncrementTick+0x10e>
    25ae:	f240 03c4 	movw	r3, #196	; 0xc4
    25b2:	f2c1 0300 	movt	r3, #4096	; 0x1000
    25b6:	681b      	ldr	r3, [r3, #0]
    25b8:	68db      	ldr	r3, [r3, #12]
    25ba:	68db      	ldr	r3, [r3, #12]
    25bc:	e001      	b.n	25c2 <vTaskIncrementTick+0x112>
    25be:	f04f 0300 	mov.w	r3, #0
    25c2:	461c      	mov	r4, r3
    25c4:	2c00      	cmp	r4, #0
    25c6:	d1b4      	bne.n	2532 <vTaskIncrementTick+0x82>
    25c8:	e00d      	b.n	25e6 <vTaskIncrementTick+0x136>
	}
	else
	{
		++uxMissedTicks;
    25ca:	f240 130c 	movw	r3, #268	; 0x10c
    25ce:	f2c1 0300 	movt	r3, #4096	; 0x1000
    25d2:	681b      	ldr	r3, [r3, #0]
    25d4:	f103 0201 	add.w	r2, r3, #1
    25d8:	f240 130c 	movw	r3, #268	; 0x10c
    25dc:	f2c1 0300 	movt	r3, #4096	; 0x1000
    25e0:	601a      	str	r2, [r3, #0]
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			extern void vApplicationTickHook( void );

			vApplicationTickHook();
    25e2:	f7fd ffab 	bl	53c <vApplicationTickHook>
	{
		extern void vApplicationTickHook( void );

		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == 0 )
    25e6:	f240 130c 	movw	r3, #268	; 0x10c
    25ea:	f2c1 0300 	movt	r3, #4096	; 0x1000
    25ee:	681b      	ldr	r3, [r3, #0]
    25f0:	2b00      	cmp	r3, #0
    25f2:	d101      	bne.n	25f8 <vTaskIncrementTick+0x148>
		{
			vApplicationTickHook();
    25f4:	f7fd ffa2 	bl	53c <vApplicationTickHook>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    25f8:	f107 070c 	add.w	r7, r7, #12
    25fc:	46bd      	mov	sp, r7
    25fe:	bd90      	pop	{r4, r7, pc}

00002600 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2600:	b480      	push	{r7}
    2602:	b083      	sub	sp, #12
    2604:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2606:	f240 1308 	movw	r3, #264	; 0x108
    260a:	f2c1 0300 	movt	r3, #4096	; 0x1000
    260e:	681b      	ldr	r3, [r3, #0]
    2610:	2b00      	cmp	r3, #0
    2612:	d014      	beq.n	263e <vTaskSwitchContext+0x3e>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2614:	f240 1310 	movw	r3, #272	; 0x110
    2618:	f2c1 0300 	movt	r3, #4096	; 0x1000
    261c:	f04f 0201 	mov.w	r2, #1
    2620:	601a      	str	r2, [r3, #0]
		return;
    2622:	e04d      	b.n	26c0 <vTaskSwitchContext+0xc0>
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    2624:	f240 1300 	movw	r3, #256	; 0x100
    2628:	f2c1 0300 	movt	r3, #4096	; 0x1000
    262c:	681b      	ldr	r3, [r3, #0]
    262e:	f103 32ff 	add.w	r2, r3, #4294967295
    2632:	f240 1300 	movw	r3, #256	; 0x100
    2636:	f2c1 0300 	movt	r3, #4096	; 0x1000
    263a:	601a      	str	r2, [r3, #0]
    263c:	e000      	b.n	2640 <vTaskSwitchContext+0x40>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    263e:	bf00      	nop
    2640:	f240 1300 	movw	r3, #256	; 0x100
    2644:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2648:	681a      	ldr	r2, [r3, #0]
    264a:	4613      	mov	r3, r2
    264c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2650:	4413      	add	r3, r2
    2652:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2656:	461a      	mov	r2, r3
    2658:	f240 0338 	movw	r3, #56	; 0x38
    265c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2660:	4413      	add	r3, r2
    2662:	681b      	ldr	r3, [r3, #0]
    2664:	2b00      	cmp	r3, #0
    2666:	d0dd      	beq.n	2624 <vTaskSwitchContext+0x24>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2668:	f240 1300 	movw	r3, #256	; 0x100
    266c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2670:	681a      	ldr	r2, [r3, #0]
    2672:	4613      	mov	r3, r2
    2674:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2678:	4413      	add	r3, r2
    267a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    267e:	461a      	mov	r2, r3
    2680:	f240 0338 	movw	r3, #56	; 0x38
    2684:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2688:	4413      	add	r3, r2
    268a:	607b      	str	r3, [r7, #4]
    268c:	687b      	ldr	r3, [r7, #4]
    268e:	685b      	ldr	r3, [r3, #4]
    2690:	685a      	ldr	r2, [r3, #4]
    2692:	687b      	ldr	r3, [r7, #4]
    2694:	605a      	str	r2, [r3, #4]
    2696:	687b      	ldr	r3, [r7, #4]
    2698:	685a      	ldr	r2, [r3, #4]
    269a:	687b      	ldr	r3, [r7, #4]
    269c:	f103 0308 	add.w	r3, r3, #8
    26a0:	429a      	cmp	r2, r3
    26a2:	d104      	bne.n	26ae <vTaskSwitchContext+0xae>
    26a4:	687b      	ldr	r3, [r7, #4]
    26a6:	685b      	ldr	r3, [r3, #4]
    26a8:	685a      	ldr	r2, [r3, #4]
    26aa:	687b      	ldr	r3, [r7, #4]
    26ac:	605a      	str	r2, [r3, #4]
    26ae:	687b      	ldr	r3, [r7, #4]
    26b0:	685b      	ldr	r3, [r3, #4]
    26b2:	68db      	ldr	r3, [r3, #12]
    26b4:	461a      	mov	r2, r3
    26b6:	f240 0334 	movw	r3, #52	; 0x34
    26ba:	f2c1 0300 	movt	r3, #4096	; 0x1000
    26be:	601a      	str	r2, [r3, #0]

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
}
    26c0:	f107 070c 	add.w	r7, r7, #12
    26c4:	46bd      	mov	sp, r7
    26c6:	bc80      	pop	{r7}
    26c8:	4770      	bx	lr
    26ca:	bf00      	nop

000026cc <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    26cc:	b580      	push	{r7, lr}
    26ce:	b084      	sub	sp, #16
    26d0:	af00      	add	r7, sp, #0
    26d2:	6078      	str	r0, [r7, #4]
    26d4:	6039      	str	r1, [r7, #0]
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    26d6:	f240 0334 	movw	r3, #52	; 0x34
    26da:	f2c1 0300 	movt	r3, #4096	; 0x1000
    26de:	681b      	ldr	r3, [r3, #0]
    26e0:	f103 0318 	add.w	r3, r3, #24
    26e4:	6878      	ldr	r0, [r7, #4]
    26e6:	4619      	mov	r1, r3
    26e8:	f7fe fdf2 	bl	12d0 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    26ec:	f240 0334 	movw	r3, #52	; 0x34
    26f0:	f2c1 0300 	movt	r3, #4096	; 0x1000
    26f4:	681b      	ldr	r3, [r3, #0]
    26f6:	f103 0304 	add.w	r3, r3, #4
    26fa:	4618      	mov	r0, r3
    26fc:	f7fe fe22 	bl	1344 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    2700:	683b      	ldr	r3, [r7, #0]
    2702:	f1b3 3fff 	cmp.w	r3, #4294967295
    2706:	d10e      	bne.n	2726 <vTaskPlaceOnEventList+0x5a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2708:	f240 0334 	movw	r3, #52	; 0x34
    270c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2710:	681b      	ldr	r3, [r3, #0]
    2712:	f103 0304 	add.w	r3, r3, #4
    2716:	f240 00e0 	movw	r0, #224	; 0xe0
    271a:	f2c1 0000 	movt	r0, #4096	; 0x1000
    271e:	4619      	mov	r1, r3
    2720:	f7fe fdae 	bl	1280 <vListInsertEnd>
    2724:	e037      	b.n	2796 <vTaskPlaceOnEventList+0xca>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2726:	f240 03f8 	movw	r3, #248	; 0xf8
    272a:	f2c1 0300 	movt	r3, #4096	; 0x1000
    272e:	681a      	ldr	r2, [r3, #0]
    2730:	683b      	ldr	r3, [r7, #0]
    2732:	4413      	add	r3, r2
    2734:	60fb      	str	r3, [r7, #12]

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2736:	f240 0334 	movw	r3, #52	; 0x34
    273a:	f2c1 0300 	movt	r3, #4096	; 0x1000
    273e:	681b      	ldr	r3, [r3, #0]
    2740:	68fa      	ldr	r2, [r7, #12]
    2742:	605a      	str	r2, [r3, #4]

			if( xTimeToWake < xTickCount )
    2744:	f240 03f8 	movw	r3, #248	; 0xf8
    2748:	f2c1 0300 	movt	r3, #4096	; 0x1000
    274c:	681b      	ldr	r3, [r3, #0]
    274e:	68fa      	ldr	r2, [r7, #12]
    2750:	429a      	cmp	r2, r3
    2752:	d210      	bcs.n	2776 <vTaskPlaceOnEventList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2754:	f240 03c8 	movw	r3, #200	; 0xc8
    2758:	f2c1 0300 	movt	r3, #4096	; 0x1000
    275c:	681a      	ldr	r2, [r3, #0]
    275e:	f240 0334 	movw	r3, #52	; 0x34
    2762:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2766:	681b      	ldr	r3, [r3, #0]
    2768:	f103 0304 	add.w	r3, r3, #4
    276c:	4610      	mov	r0, r2
    276e:	4619      	mov	r1, r3
    2770:	f7fe fdae 	bl	12d0 <vListInsert>
    2774:	e00f      	b.n	2796 <vTaskPlaceOnEventList+0xca>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2776:	f240 03c4 	movw	r3, #196	; 0xc4
    277a:	f2c1 0300 	movt	r3, #4096	; 0x1000
    277e:	681a      	ldr	r2, [r3, #0]
    2780:	f240 0334 	movw	r3, #52	; 0x34
    2784:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2788:	681b      	ldr	r3, [r3, #0]
    278a:	f103 0304 	add.w	r3, r3, #4
    278e:	4610      	mov	r0, r2
    2790:	4619      	mov	r1, r3
    2792:	f7fe fd9d 	bl	12d0 <vListInsert>
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
    2796:	f107 0710 	add.w	r7, r7, #16
    279a:	46bd      	mov	sp, r7
    279c:	bd80      	pop	{r7, pc}
    279e:	bf00      	nop

000027a0 <xTaskRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    27a0:	b580      	push	{r7, lr}
    27a2:	b084      	sub	sp, #16
    27a4:	af00      	add	r7, sp, #0
    27a6:	6078      	str	r0, [r7, #4]
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    27a8:	687b      	ldr	r3, [r7, #4]
    27aa:	681b      	ldr	r3, [r3, #0]
    27ac:	2b00      	cmp	r3, #0
    27ae:	d003      	beq.n	27b8 <xTaskRemoveFromEventList+0x18>
    27b0:	687b      	ldr	r3, [r7, #4]
    27b2:	68db      	ldr	r3, [r3, #12]
    27b4:	68db      	ldr	r3, [r3, #12]
    27b6:	e001      	b.n	27bc <xTaskRemoveFromEventList+0x1c>
    27b8:	f04f 0300 	mov.w	r3, #0
    27bc:	60bb      	str	r3, [r7, #8]
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    27be:	68bb      	ldr	r3, [r7, #8]
    27c0:	f103 0318 	add.w	r3, r3, #24
    27c4:	4618      	mov	r0, r3
    27c6:	f7fe fdbd 	bl	1344 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    27ca:	f240 1308 	movw	r3, #264	; 0x108
    27ce:	f2c1 0300 	movt	r3, #4096	; 0x1000
    27d2:	681b      	ldr	r3, [r3, #0]
    27d4:	2b00      	cmp	r3, #0
    27d6:	d12b      	bne.n	2830 <xTaskRemoveFromEventList+0x90>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    27d8:	68bb      	ldr	r3, [r7, #8]
    27da:	f103 0304 	add.w	r3, r3, #4
    27de:	4618      	mov	r0, r3
    27e0:	f7fe fdb0 	bl	1344 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    27e4:	68bb      	ldr	r3, [r7, #8]
    27e6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    27e8:	f240 1300 	movw	r3, #256	; 0x100
    27ec:	f2c1 0300 	movt	r3, #4096	; 0x1000
    27f0:	681b      	ldr	r3, [r3, #0]
    27f2:	429a      	cmp	r2, r3
    27f4:	d906      	bls.n	2804 <xTaskRemoveFromEventList+0x64>
    27f6:	68bb      	ldr	r3, [r7, #8]
    27f8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    27fa:	f240 1300 	movw	r3, #256	; 0x100
    27fe:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2802:	601a      	str	r2, [r3, #0]
    2804:	68bb      	ldr	r3, [r7, #8]
    2806:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2808:	4613      	mov	r3, r2
    280a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    280e:	4413      	add	r3, r2
    2810:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2814:	461a      	mov	r2, r3
    2816:	f240 0338 	movw	r3, #56	; 0x38
    281a:	f2c1 0300 	movt	r3, #4096	; 0x1000
    281e:	441a      	add	r2, r3
    2820:	68bb      	ldr	r3, [r7, #8]
    2822:	f103 0304 	add.w	r3, r3, #4
    2826:	4610      	mov	r0, r2
    2828:	4619      	mov	r1, r3
    282a:	f7fe fd29 	bl	1280 <vListInsertEnd>
    282e:	e009      	b.n	2844 <xTaskRemoveFromEventList+0xa4>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2830:	68bb      	ldr	r3, [r7, #8]
    2832:	f103 0318 	add.w	r3, r3, #24
    2836:	f240 00cc 	movw	r0, #204	; 0xcc
    283a:	f2c1 0000 	movt	r0, #4096	; 0x1000
    283e:	4619      	mov	r1, r3
    2840:	f7fe fd1e 	bl	1280 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2844:	68bb      	ldr	r3, [r7, #8]
    2846:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2848:	f240 0334 	movw	r3, #52	; 0x34
    284c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2850:	681b      	ldr	r3, [r3, #0]
    2852:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2854:	429a      	cmp	r2, r3
    2856:	d303      	bcc.n	2860 <xTaskRemoveFromEventList+0xc0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2858:	f04f 0301 	mov.w	r3, #1
    285c:	60fb      	str	r3, [r7, #12]
    285e:	e002      	b.n	2866 <xTaskRemoveFromEventList+0xc6>
	}
	else
	{
		xReturn = pdFALSE;
    2860:	f04f 0300 	mov.w	r3, #0
    2864:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
    2866:	68fb      	ldr	r3, [r7, #12]
}
    2868:	4618      	mov	r0, r3
    286a:	f107 0710 	add.w	r7, r7, #16
    286e:	46bd      	mov	sp, r7
    2870:	bd80      	pop	{r7, pc}
    2872:	bf00      	nop

00002874 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2874:	b480      	push	{r7}
    2876:	b083      	sub	sp, #12
    2878:	af00      	add	r7, sp, #0
    287a:	6078      	str	r0, [r7, #4]
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    287c:	f240 1314 	movw	r3, #276	; 0x114
    2880:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2884:	681a      	ldr	r2, [r3, #0]
    2886:	687b      	ldr	r3, [r7, #4]
    2888:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    288a:	f240 03f8 	movw	r3, #248	; 0xf8
    288e:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2892:	681a      	ldr	r2, [r3, #0]
    2894:	687b      	ldr	r3, [r7, #4]
    2896:	605a      	str	r2, [r3, #4]
}
    2898:	f107 070c 	add.w	r7, r7, #12
    289c:	46bd      	mov	sp, r7
    289e:	bc80      	pop	{r7}
    28a0:	4770      	bx	lr
    28a2:	bf00      	nop

000028a4 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    28a4:	b580      	push	{r7, lr}
    28a6:	b084      	sub	sp, #16
    28a8:	af00      	add	r7, sp, #0
    28aa:	6078      	str	r0, [r7, #4]
    28ac:	6039      	str	r1, [r7, #0]
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    28ae:	f000 fae1 	bl	2e74 <vPortEnterCritical>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    28b2:	683b      	ldr	r3, [r7, #0]
    28b4:	681b      	ldr	r3, [r3, #0]
    28b6:	f1b3 3fff 	cmp.w	r3, #4294967295
    28ba:	d103      	bne.n	28c4 <xTaskCheckForTimeOut+0x20>
			{
				xReturn = pdFALSE;
    28bc:	f04f 0300 	mov.w	r3, #0
    28c0:	60fb      	str	r3, [r7, #12]
    28c2:	e03a      	b.n	293a <xTaskCheckForTimeOut+0x96>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    28c4:	687b      	ldr	r3, [r7, #4]
    28c6:	681a      	ldr	r2, [r3, #0]
    28c8:	f240 1314 	movw	r3, #276	; 0x114
    28cc:	f2c1 0300 	movt	r3, #4096	; 0x1000
    28d0:	681b      	ldr	r3, [r3, #0]
    28d2:	429a      	cmp	r2, r3
    28d4:	d00c      	beq.n	28f0 <xTaskCheckForTimeOut+0x4c>
    28d6:	687b      	ldr	r3, [r7, #4]
    28d8:	685a      	ldr	r2, [r3, #4]
    28da:	f240 03f8 	movw	r3, #248	; 0xf8
    28de:	f2c1 0300 	movt	r3, #4096	; 0x1000
    28e2:	681b      	ldr	r3, [r3, #0]
    28e4:	429a      	cmp	r2, r3
    28e6:	d803      	bhi.n	28f0 <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    28e8:	f04f 0301 	mov.w	r3, #1
    28ec:	60fb      	str	r3, [r7, #12]
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    28ee:	e024      	b.n	293a <xTaskCheckForTimeOut+0x96>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) < ( portTickType ) *pxTicksToWait )
    28f0:	f240 03f8 	movw	r3, #248	; 0xf8
    28f4:	f2c1 0300 	movt	r3, #4096	; 0x1000
    28f8:	681a      	ldr	r2, [r3, #0]
    28fa:	687b      	ldr	r3, [r7, #4]
    28fc:	685b      	ldr	r3, [r3, #4]
    28fe:	ebc3 0202 	rsb	r2, r3, r2
    2902:	683b      	ldr	r3, [r7, #0]
    2904:	681b      	ldr	r3, [r3, #0]
    2906:	429a      	cmp	r2, r3
    2908:	d214      	bcs.n	2934 <xTaskCheckForTimeOut+0x90>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    290a:	683b      	ldr	r3, [r7, #0]
    290c:	681a      	ldr	r2, [r3, #0]
    290e:	687b      	ldr	r3, [r7, #4]
    2910:	6859      	ldr	r1, [r3, #4]
    2912:	f240 03f8 	movw	r3, #248	; 0xf8
    2916:	f2c1 0300 	movt	r3, #4096	; 0x1000
    291a:	681b      	ldr	r3, [r3, #0]
    291c:	ebc3 0301 	rsb	r3, r3, r1
    2920:	441a      	add	r2, r3
    2922:	683b      	ldr	r3, [r7, #0]
    2924:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
    2926:	6878      	ldr	r0, [r7, #4]
    2928:	f7ff ffa4 	bl	2874 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    292c:	f04f 0300 	mov.w	r3, #0
    2930:	60fb      	str	r3, [r7, #12]
    2932:	e002      	b.n	293a <xTaskCheckForTimeOut+0x96>
		}
		else
		{
			xReturn = pdTRUE;
    2934:	f04f 0301 	mov.w	r3, #1
    2938:	60fb      	str	r3, [r7, #12]
		}
	}
	portEXIT_CRITICAL();
    293a:	f000 fab1 	bl	2ea0 <vPortExitCritical>

	return xReturn;
    293e:	68fb      	ldr	r3, [r7, #12]
}
    2940:	4618      	mov	r0, r3
    2942:	f107 0710 	add.w	r7, r7, #16
    2946:	46bd      	mov	sp, r7
    2948:	bd80      	pop	{r7, pc}
    294a:	bf00      	nop

0000294c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    294c:	b480      	push	{r7}
    294e:	af00      	add	r7, sp, #0
	xMissedYield = pdTRUE;
    2950:	f240 1310 	movw	r3, #272	; 0x110
    2954:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2958:	f04f 0201 	mov.w	r2, #1
    295c:	601a      	str	r2, [r3, #0]
}
    295e:	46bd      	mov	sp, r7
    2960:	bc80      	pop	{r7}
    2962:	4770      	bx	lr

00002964 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2964:	b580      	push	{r7, lr}
    2966:	b082      	sub	sp, #8
    2968:	af00      	add	r7, sp, #0
    296a:	6078      	str	r0, [r7, #4]
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    296c:	f000 f88a 	bl	2a84 <prvCheckTasksWaitingTermination>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
    2970:	e7fc      	b.n	296c <prvIdleTask+0x8>
    2972:	bf00      	nop

00002974 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2974:	b580      	push	{r7, lr}
    2976:	b084      	sub	sp, #16
    2978:	af00      	add	r7, sp, #0
    297a:	60f8      	str	r0, [r7, #12]
    297c:	60b9      	str	r1, [r7, #8]
    297e:	607a      	str	r2, [r7, #4]
    2980:	603b      	str	r3, [r7, #0]
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2982:	68fb      	ldr	r3, [r7, #12]
    2984:	f103 0334 	add.w	r3, r3, #52	; 0x34
    2988:	461a      	mov	r2, r3
    298a:	68bb      	ldr	r3, [r7, #8]
    298c:	4610      	mov	r0, r2
    298e:	4619      	mov	r1, r3
    2990:	f04f 020c 	mov.w	r2, #12
    2994:	f000 fc22 	bl	31dc <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    2998:	68fb      	ldr	r3, [r7, #12]
    299a:	f04f 0200 	mov.w	r2, #0
    299e:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    29a2:	687b      	ldr	r3, [r7, #4]
    29a4:	2b04      	cmp	r3, #4
    29a6:	d902      	bls.n	29ae <prvInitialiseTCBVariables+0x3a>
	{
		uxPriority = configMAX_PRIORITIES - 1;
    29a8:	f04f 0304 	mov.w	r3, #4
    29ac:	607b      	str	r3, [r7, #4]
	}

	pxTCB->uxPriority = uxPriority;
    29ae:	68fb      	ldr	r3, [r7, #12]
    29b0:	687a      	ldr	r2, [r7, #4]
    29b2:	62da      	str	r2, [r3, #44]	; 0x2c
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    29b4:	68fb      	ldr	r3, [r7, #12]
    29b6:	f103 0304 	add.w	r3, r3, #4
    29ba:	4618      	mov	r0, r3
    29bc:	f7fe fc52 	bl	1264 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    29c0:	68fb      	ldr	r3, [r7, #12]
    29c2:	f103 0318 	add.w	r3, r3, #24
    29c6:	4618      	mov	r0, r3
    29c8:	f7fe fc4c 	bl	1264 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    29cc:	68fb      	ldr	r3, [r7, #12]
    29ce:	68fa      	ldr	r2, [r7, #12]
    29d0:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    29d2:	687b      	ldr	r3, [r7, #4]
    29d4:	f1c3 0205 	rsb	r2, r3, #5
    29d8:	68fb      	ldr	r3, [r7, #12]
    29da:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    29dc:	68fb      	ldr	r3, [r7, #12]
    29de:	68fa      	ldr	r2, [r7, #12]
    29e0:	625a      	str	r2, [r3, #36]	; 0x24
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    29e2:	f107 0710 	add.w	r7, r7, #16
    29e6:	46bd      	mov	sp, r7
    29e8:	bd80      	pop	{r7, pc}
    29ea:	bf00      	nop

000029ec <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    29ec:	b580      	push	{r7, lr}
    29ee:	b082      	sub	sp, #8
    29f0:	af00      	add	r7, sp, #0
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    29f2:	f04f 0300 	mov.w	r3, #0
    29f6:	607b      	str	r3, [r7, #4]
    29f8:	e013      	b.n	2a22 <prvInitialiseTaskLists+0x36>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    29fa:	687a      	ldr	r2, [r7, #4]
    29fc:	4613      	mov	r3, r2
    29fe:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2a02:	4413      	add	r3, r2
    2a04:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2a08:	461a      	mov	r2, r3
    2a0a:	f240 0338 	movw	r3, #56	; 0x38
    2a0e:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2a12:	4413      	add	r3, r2
    2a14:	4618      	mov	r0, r3
    2a16:	f7fe fc01 	bl	121c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2a1a:	687b      	ldr	r3, [r7, #4]
    2a1c:	f103 0301 	add.w	r3, r3, #1
    2a20:	607b      	str	r3, [r7, #4]
    2a22:	687b      	ldr	r3, [r7, #4]
    2a24:	2b04      	cmp	r3, #4
    2a26:	d9e8      	bls.n	29fa <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2a28:	f240 009c 	movw	r0, #156	; 0x9c
    2a2c:	f2c1 0000 	movt	r0, #4096	; 0x1000
    2a30:	f7fe fbf4 	bl	121c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2a34:	f240 00b0 	movw	r0, #176	; 0xb0
    2a38:	f2c1 0000 	movt	r0, #4096	; 0x1000
    2a3c:	f7fe fbee 	bl	121c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2a40:	f240 00cc 	movw	r0, #204	; 0xcc
    2a44:	f2c1 0000 	movt	r0, #4096	; 0x1000
    2a48:	f7fe fbe8 	bl	121c <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    2a4c:	f240 00e0 	movw	r0, #224	; 0xe0
    2a50:	f2c1 0000 	movt	r0, #4096	; 0x1000
    2a54:	f7fe fbe2 	bl	121c <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2a58:	f240 03c4 	movw	r3, #196	; 0xc4
    2a5c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2a60:	f240 029c 	movw	r2, #156	; 0x9c
    2a64:	f2c1 0200 	movt	r2, #4096	; 0x1000
    2a68:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2a6a:	f240 03c8 	movw	r3, #200	; 0xc8
    2a6e:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2a72:	f240 02b0 	movw	r2, #176	; 0xb0
    2a76:	f2c1 0200 	movt	r2, #4096	; 0x1000
    2a7a:	601a      	str	r2, [r3, #0]
}
    2a7c:	f107 0708 	add.w	r7, r7, #8
    2a80:	46bd      	mov	sp, r7
    2a82:	bd80      	pop	{r7, pc}

00002a84 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2a84:	b480      	push	{r7}
    2a86:	af00      	add	r7, sp, #0
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif
}
    2a88:	46bd      	mov	sp, r7
    2a8a:	bc80      	pop	{r7}
    2a8c:	4770      	bx	lr
    2a8e:	bf00      	nop

00002a90 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    2a90:	b580      	push	{r7, lr}
    2a92:	b084      	sub	sp, #16
    2a94:	af00      	add	r7, sp, #0
    2a96:	4603      	mov	r3, r0
    2a98:	6039      	str	r1, [r7, #0]
    2a9a:	80fb      	strh	r3, [r7, #6]
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2a9c:	f04f 0040 	mov.w	r0, #64	; 0x40
    2aa0:	f000 f82c 	bl	2afc <pvPortMalloc>
    2aa4:	4603      	mov	r3, r0
    2aa6:	60fb      	str	r3, [r7, #12]

	if( pxNewTCB != NULL )
    2aa8:	68fb      	ldr	r3, [r7, #12]
    2aaa:	2b00      	cmp	r3, #0
    2aac:	d01f      	beq.n	2aee <prvAllocateTCBAndStack+0x5e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2aae:	88fb      	ldrh	r3, [r7, #6]
    2ab0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2ab4:	4618      	mov	r0, r3
    2ab6:	f000 f821 	bl	2afc <pvPortMalloc>
    2aba:	4603      	mov	r3, r0
    2abc:	461a      	mov	r2, r3
    2abe:	68fb      	ldr	r3, [r7, #12]
    2ac0:	631a      	str	r2, [r3, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
    2ac2:	68fb      	ldr	r3, [r7, #12]
    2ac4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    2ac6:	2b00      	cmp	r3, #0
    2ac8:	d106      	bne.n	2ad8 <prvAllocateTCBAndStack+0x48>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2aca:	68f8      	ldr	r0, [r7, #12]
    2acc:	f000 f8f8 	bl	2cc0 <vPortFree>
			pxNewTCB = NULL;
    2ad0:	f04f 0300 	mov.w	r3, #0
    2ad4:	60fb      	str	r3, [r7, #12]
    2ad6:	e00a      	b.n	2aee <prvAllocateTCBAndStack+0x5e>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    2ad8:	68fb      	ldr	r3, [r7, #12]
    2ada:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    2adc:	88fb      	ldrh	r3, [r7, #6]
    2ade:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2ae2:	4610      	mov	r0, r2
    2ae4:	f04f 01a5 	mov.w	r1, #165	; 0xa5
    2ae8:	461a      	mov	r2, r3
    2aea:	f000 fb0d 	bl	3108 <memset>
		}
	}

	return pxNewTCB;
    2aee:	68fb      	ldr	r3, [r7, #12]
}
    2af0:	4618      	mov	r0, r3
    2af2:	f107 0710 	add.w	r7, r7, #16
    2af6:	46bd      	mov	sp, r7
    2af8:	bd80      	pop	{r7, pc}
    2afa:	bf00      	nop

00002afc <pvPortMalloc>:
	xFreeBytesRemaining = configTOTAL_HEAP_SIZE;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2afc:	b580      	push	{r7, lr}
    2afe:	b08a      	sub	sp, #40	; 0x28
    2b00:	af00      	add	r7, sp, #0
    2b02:	6078      	str	r0, [r7, #4]
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    2b04:	f04f 0300 	mov.w	r3, #0
    2b08:	61bb      	str	r3, [r7, #24]

	vTaskSuspendAll();
    2b0a:	f7ff fbef 	bl	22ec <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    2b0e:	f644 5334 	movw	r3, #19764	; 0x4d34
    2b12:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2b16:	681b      	ldr	r3, [r3, #0]
    2b18:	2b00      	cmp	r3, #0
    2b1a:	d13a      	bne.n	2b92 <pvPortMalloc+0x96>
		{
			prvHeapInit();
    2b1c:	f240 1220 	movw	r2, #288	; 0x120
    2b20:	f2c1 0200 	movt	r2, #4096	; 0x1000
    2b24:	f644 5320 	movw	r3, #19744	; 0x4d20
    2b28:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2b2c:	601a      	str	r2, [r3, #0]
    2b2e:	f644 5320 	movw	r3, #19744	; 0x4d20
    2b32:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2b36:	f04f 0200 	mov.w	r2, #0
    2b3a:	605a      	str	r2, [r3, #4]
    2b3c:	f644 5328 	movw	r3, #19752	; 0x4d28
    2b40:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2b44:	f44f 4298 	mov.w	r2, #19456	; 0x4c00
    2b48:	605a      	str	r2, [r3, #4]
    2b4a:	f644 5328 	movw	r3, #19752	; 0x4d28
    2b4e:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2b52:	f04f 0200 	mov.w	r2, #0
    2b56:	601a      	str	r2, [r3, #0]
    2b58:	f240 1320 	movw	r3, #288	; 0x120
    2b5c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2b60:	61fb      	str	r3, [r7, #28]
    2b62:	69fb      	ldr	r3, [r7, #28]
    2b64:	f44f 4298 	mov.w	r2, #19456	; 0x4c00
    2b68:	605a      	str	r2, [r3, #4]
    2b6a:	69fa      	ldr	r2, [r7, #28]
    2b6c:	f644 5328 	movw	r3, #19752	; 0x4d28
    2b70:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2b74:	6013      	str	r3, [r2, #0]
    2b76:	f644 5330 	movw	r3, #19760	; 0x4d30
    2b7a:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2b7e:	f44f 4298 	mov.w	r2, #19456	; 0x4c00
    2b82:	601a      	str	r2, [r3, #0]
			xHeapHasBeenInitialised = pdTRUE;
    2b84:	f644 5334 	movw	r3, #19764	; 0x4d34
    2b88:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2b8c:	f04f 0201 	mov.w	r2, #1
    2b90:	601a      	str	r2, [r3, #0]
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    2b92:	687b      	ldr	r3, [r7, #4]
    2b94:	2b00      	cmp	r3, #0
    2b96:	d012      	beq.n	2bbe <pvPortMalloc+0xc2>
		{
			xWantedSize += heapSTRUCT_SIZE;
    2b98:	f243 2368 	movw	r3, #12904	; 0x3268
    2b9c:	f2c0 0300 	movt	r3, #0
    2ba0:	881b      	ldrh	r3, [r3, #0]
    2ba2:	687a      	ldr	r2, [r7, #4]
    2ba4:	4413      	add	r3, r2
    2ba6:	607b      	str	r3, [r7, #4]

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( xWantedSize & portBYTE_ALIGNMENT_MASK )
    2ba8:	687b      	ldr	r3, [r7, #4]
    2baa:	f003 0307 	and.w	r3, r3, #7
    2bae:	2b00      	cmp	r3, #0
    2bb0:	d005      	beq.n	2bbe <pvPortMalloc+0xc2>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    2bb2:	687b      	ldr	r3, [r7, #4]
    2bb4:	f023 0307 	bic.w	r3, r3, #7
    2bb8:	f103 0308 	add.w	r3, r3, #8
    2bbc:	607b      	str	r3, [r7, #4]
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    2bbe:	687b      	ldr	r3, [r7, #4]
    2bc0:	2b00      	cmp	r3, #0
    2bc2:	d074      	beq.n	2cae <pvPortMalloc+0x1b2>
    2bc4:	687a      	ldr	r2, [r7, #4]
    2bc6:	f644 33ff 	movw	r3, #19455	; 0x4bff
    2bca:	429a      	cmp	r2, r3
    2bcc:	d86f      	bhi.n	2cae <pvPortMalloc+0x1b2>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    2bce:	f644 5320 	movw	r3, #19744	; 0x4d20
    2bd2:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2bd6:	613b      	str	r3, [r7, #16]
			pxBlock = xStart.pxNextFreeBlock;
    2bd8:	f644 5320 	movw	r3, #19744	; 0x4d20
    2bdc:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2be0:	681b      	ldr	r3, [r3, #0]
    2be2:	60fb      	str	r3, [r7, #12]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    2be4:	e004      	b.n	2bf0 <pvPortMalloc+0xf4>
			{
				pxPreviousBlock = pxBlock;
    2be6:	68fb      	ldr	r3, [r7, #12]
    2be8:	613b      	str	r3, [r7, #16]
				pxBlock = pxBlock->pxNextFreeBlock;
    2bea:	68fb      	ldr	r3, [r7, #12]
    2bec:	681b      	ldr	r3, [r3, #0]
    2bee:	60fb      	str	r3, [r7, #12]
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    2bf0:	68fb      	ldr	r3, [r7, #12]
    2bf2:	685a      	ldr	r2, [r3, #4]
    2bf4:	687b      	ldr	r3, [r7, #4]
    2bf6:	429a      	cmp	r2, r3
    2bf8:	d203      	bcs.n	2c02 <pvPortMalloc+0x106>
    2bfa:	68fb      	ldr	r3, [r7, #12]
    2bfc:	681b      	ldr	r3, [r3, #0]
    2bfe:	2b00      	cmp	r3, #0
    2c00:	d1f1      	bne.n	2be6 <pvPortMalloc+0xea>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    2c02:	68fa      	ldr	r2, [r7, #12]
    2c04:	f644 5328 	movw	r3, #19752	; 0x4d28
    2c08:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2c0c:	429a      	cmp	r2, r3
    2c0e:	d04e      	beq.n	2cae <pvPortMalloc+0x1b2>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    2c10:	693b      	ldr	r3, [r7, #16]
    2c12:	681a      	ldr	r2, [r3, #0]
    2c14:	f243 2368 	movw	r3, #12904	; 0x3268
    2c18:	f2c0 0300 	movt	r3, #0
    2c1c:	881b      	ldrh	r3, [r3, #0]
    2c1e:	4413      	add	r3, r2
    2c20:	61bb      	str	r3, [r7, #24]

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    2c22:	68fb      	ldr	r3, [r7, #12]
    2c24:	681a      	ldr	r2, [r3, #0]
    2c26:	693b      	ldr	r3, [r7, #16]
    2c28:	601a      	str	r2, [r3, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    2c2a:	68fb      	ldr	r3, [r7, #12]
    2c2c:	685a      	ldr	r2, [r3, #4]
    2c2e:	687b      	ldr	r3, [r7, #4]
    2c30:	ebc3 0202 	rsb	r2, r3, r2
    2c34:	f243 2368 	movw	r3, #12904	; 0x3268
    2c38:	f2c0 0300 	movt	r3, #0
    2c3c:	881b      	ldrh	r3, [r3, #0]
    2c3e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    2c42:	429a      	cmp	r2, r3
    2c44:	d926      	bls.n	2c94 <pvPortMalloc+0x198>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    2c46:	68fa      	ldr	r2, [r7, #12]
    2c48:	687b      	ldr	r3, [r7, #4]
    2c4a:	4413      	add	r3, r2
    2c4c:	617b      	str	r3, [r7, #20]

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    2c4e:	68fb      	ldr	r3, [r7, #12]
    2c50:	685a      	ldr	r2, [r3, #4]
    2c52:	687b      	ldr	r3, [r7, #4]
    2c54:	ebc3 0202 	rsb	r2, r3, r2
    2c58:	697b      	ldr	r3, [r7, #20]
    2c5a:	605a      	str	r2, [r3, #4]
					pxBlock->xBlockSize = xWantedSize;
    2c5c:	68fb      	ldr	r3, [r7, #12]
    2c5e:	687a      	ldr	r2, [r7, #4]
    2c60:	605a      	str	r2, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    2c62:	697b      	ldr	r3, [r7, #20]
    2c64:	685b      	ldr	r3, [r3, #4]
    2c66:	627b      	str	r3, [r7, #36]	; 0x24
    2c68:	f644 5320 	movw	r3, #19744	; 0x4d20
    2c6c:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2c70:	623b      	str	r3, [r7, #32]
    2c72:	e002      	b.n	2c7a <pvPortMalloc+0x17e>
    2c74:	6a3b      	ldr	r3, [r7, #32]
    2c76:	681b      	ldr	r3, [r3, #0]
    2c78:	623b      	str	r3, [r7, #32]
    2c7a:	6a3b      	ldr	r3, [r7, #32]
    2c7c:	681b      	ldr	r3, [r3, #0]
    2c7e:	685a      	ldr	r2, [r3, #4]
    2c80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2c82:	429a      	cmp	r2, r3
    2c84:	d3f6      	bcc.n	2c74 <pvPortMalloc+0x178>
    2c86:	6a3b      	ldr	r3, [r7, #32]
    2c88:	681a      	ldr	r2, [r3, #0]
    2c8a:	697b      	ldr	r3, [r7, #20]
    2c8c:	601a      	str	r2, [r3, #0]
    2c8e:	6a3b      	ldr	r3, [r7, #32]
    2c90:	697a      	ldr	r2, [r7, #20]
    2c92:	601a      	str	r2, [r3, #0]
				}
				
				xFreeBytesRemaining -= xWantedSize;
    2c94:	f644 5330 	movw	r3, #19760	; 0x4d30
    2c98:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2c9c:	681a      	ldr	r2, [r3, #0]
    2c9e:	687b      	ldr	r3, [r7, #4]
    2ca0:	ebc3 0202 	rsb	r2, r3, r2
    2ca4:	f644 5330 	movw	r3, #19760	; 0x4d30
    2ca8:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2cac:	601a      	str	r2, [r3, #0]
			}
		}
	}
	xTaskResumeAll();
    2cae:	f7ff fb2f 	bl	2310 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    2cb2:	69bb      	ldr	r3, [r7, #24]
}
    2cb4:	4618      	mov	r0, r3
    2cb6:	f107 0728 	add.w	r7, r7, #40	; 0x28
    2cba:	46bd      	mov	sp, r7
    2cbc:	bd80      	pop	{r7, pc}
    2cbe:	bf00      	nop

00002cc0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2cc0:	b580      	push	{r7, lr}
    2cc2:	b086      	sub	sp, #24
    2cc4:	af00      	add	r7, sp, #0
    2cc6:	6078      	str	r0, [r7, #4]
unsigned char *puc = ( unsigned char * ) pv;
    2cc8:	687b      	ldr	r3, [r7, #4]
    2cca:	60bb      	str	r3, [r7, #8]
xBlockLink *pxLink;

	if( pv )
    2ccc:	687b      	ldr	r3, [r7, #4]
    2cce:	2b00      	cmp	r3, #0
    2cd0:	d035      	beq.n	2d3e <vPortFree+0x7e>
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    2cd2:	f243 2368 	movw	r3, #12904	; 0x3268
    2cd6:	f2c0 0300 	movt	r3, #0
    2cda:	881b      	ldrh	r3, [r3, #0]
    2cdc:	f1c3 0300 	rsb	r3, r3, #0
    2ce0:	68ba      	ldr	r2, [r7, #8]
    2ce2:	4413      	add	r3, r2
    2ce4:	60bb      	str	r3, [r7, #8]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
    2ce6:	68bb      	ldr	r3, [r7, #8]
    2ce8:	60fb      	str	r3, [r7, #12]

		vTaskSuspendAll();
    2cea:	f7ff faff 	bl	22ec <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    2cee:	68fb      	ldr	r3, [r7, #12]
    2cf0:	685b      	ldr	r3, [r3, #4]
    2cf2:	617b      	str	r3, [r7, #20]
    2cf4:	f644 5320 	movw	r3, #19744	; 0x4d20
    2cf8:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2cfc:	613b      	str	r3, [r7, #16]
    2cfe:	e002      	b.n	2d06 <vPortFree+0x46>
    2d00:	693b      	ldr	r3, [r7, #16]
    2d02:	681b      	ldr	r3, [r3, #0]
    2d04:	613b      	str	r3, [r7, #16]
    2d06:	693b      	ldr	r3, [r7, #16]
    2d08:	681b      	ldr	r3, [r3, #0]
    2d0a:	685a      	ldr	r2, [r3, #4]
    2d0c:	697b      	ldr	r3, [r7, #20]
    2d0e:	429a      	cmp	r2, r3
    2d10:	d3f6      	bcc.n	2d00 <vPortFree+0x40>
    2d12:	693b      	ldr	r3, [r7, #16]
    2d14:	681a      	ldr	r2, [r3, #0]
    2d16:	68fb      	ldr	r3, [r7, #12]
    2d18:	601a      	str	r2, [r3, #0]
    2d1a:	693b      	ldr	r3, [r7, #16]
    2d1c:	68fa      	ldr	r2, [r7, #12]
    2d1e:	601a      	str	r2, [r3, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
    2d20:	68fb      	ldr	r3, [r7, #12]
    2d22:	685a      	ldr	r2, [r3, #4]
    2d24:	f644 5330 	movw	r3, #19760	; 0x4d30
    2d28:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2d2c:	681b      	ldr	r3, [r3, #0]
    2d2e:	441a      	add	r2, r3
    2d30:	f644 5330 	movw	r3, #19760	; 0x4d30
    2d34:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2d38:	601a      	str	r2, [r3, #0]
		}
		xTaskResumeAll();
    2d3a:	f7ff fae9 	bl	2310 <xTaskResumeAll>
	}
}
    2d3e:	f107 0718 	add.w	r7, r7, #24
    2d42:	46bd      	mov	sp, r7
    2d44:	bd80      	pop	{r7, pc}
    2d46:	bf00      	nop

00002d48 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2d48:	b480      	push	{r7}
    2d4a:	af00      	add	r7, sp, #0
	return xFreeBytesRemaining;
    2d4c:	f644 5330 	movw	r3, #19760	; 0x4d30
    2d50:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2d54:	681b      	ldr	r3, [r3, #0]
}
    2d56:	4618      	mov	r0, r3
    2d58:	46bd      	mov	sp, r7
    2d5a:	bc80      	pop	{r7}
    2d5c:	4770      	bx	lr
    2d5e:	bf00      	nop

00002d60 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2d60:	b480      	push	{r7}
    2d62:	af00      	add	r7, sp, #0
	/* This just exists to keep the linker quiet. */
}
    2d64:	46bd      	mov	sp, r7
    2d66:	bc80      	pop	{r7}
    2d68:	4770      	bx	lr
    2d6a:	bf00      	nop

00002d6c <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2d6c:	b480      	push	{r7}
    2d6e:	b085      	sub	sp, #20
    2d70:	af00      	add	r7, sp, #0
    2d72:	60f8      	str	r0, [r7, #12]
    2d74:	60b9      	str	r1, [r7, #8]
    2d76:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
    2d78:	68fb      	ldr	r3, [r7, #12]
    2d7a:	f1a3 0304 	sub.w	r3, r3, #4
    2d7e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
    2d80:	68fb      	ldr	r3, [r7, #12]
    2d82:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    2d86:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
    2d88:	68fb      	ldr	r3, [r7, #12]
    2d8a:	f1a3 0304 	sub.w	r3, r3, #4
    2d8e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
    2d90:	68ba      	ldr	r2, [r7, #8]
    2d92:	68fb      	ldr	r3, [r7, #12]
    2d94:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
    2d96:	68fb      	ldr	r3, [r7, #12]
    2d98:	f1a3 0304 	sub.w	r3, r3, #4
    2d9c:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = 0;	/* LR */
    2d9e:	68fb      	ldr	r3, [r7, #12]
    2da0:	f04f 0200 	mov.w	r2, #0
    2da4:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
    2da6:	68fb      	ldr	r3, [r7, #12]
    2da8:	f1a3 0314 	sub.w	r3, r3, #20
    2dac:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
    2dae:	687a      	ldr	r2, [r7, #4]
    2db0:	68fb      	ldr	r3, [r7, #12]
    2db2:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
    2db4:	68fb      	ldr	r3, [r7, #12]
    2db6:	f1a3 0320 	sub.w	r3, r3, #32
    2dba:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
    2dbc:	68fb      	ldr	r3, [r7, #12]
}
    2dbe:	4618      	mov	r0, r3
    2dc0:	f107 0714 	add.w	r7, r7, #20
    2dc4:	46bd      	mov	sp, r7
    2dc6:	bc80      	pop	{r7}
    2dc8:	4770      	bx	lr
    2dca:	bf00      	nop

00002dcc <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
    2dcc:	4b06      	ldr	r3, [pc, #24]	; (2de8 <pxCurrentTCBConst2>)
    2dce:	6819      	ldr	r1, [r3, #0]
    2dd0:	6808      	ldr	r0, [r1, #0]
    2dd2:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
    2dd6:	f380 8809 	msr	PSP, r0
    2dda:	f04f 0000 	mov.w	r0, #0
    2dde:	f380 8811 	msr	BASEPRI, r0
    2de2:	f04e 0e0d 	orr.w	lr, lr, #13
    2de6:	4770      	bx	lr

00002de8 <pxCurrentTCBConst2>:
    2de8:	10000034 	.word	0x10000034

00002dec <vPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

void vPortStartFirstTask( void )
{
	__asm volatile(
    2dec:	4802      	ldr	r0, [pc, #8]	; (2df8 <vPortStartFirstTask+0xc>)
    2dee:	6800      	ldr	r0, [r0, #0]
    2df0:	6800      	ldr	r0, [r0, #0]
    2df2:	f380 8808 	msr	MSP, r0
    2df6:	df00      	svc	0
    2df8:	e000ed08 	.word	0xe000ed08

00002dfc <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
    2dfc:	b580      	push	{r7, lr}
    2dfe:	af00      	add	r7, sp, #0
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
    2e00:	f64e 5320 	movw	r3, #60704	; 0xed20
    2e04:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2e08:	f64e 5220 	movw	r2, #60704	; 0xed20
    2e0c:	f2ce 0200 	movt	r2, #57344	; 0xe000
    2e10:	6812      	ldr	r2, [r2, #0]
    2e12:	f442 0278 	orr.w	r2, r2, #16252928	; 0xf80000
    2e16:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
    2e18:	f64e 5320 	movw	r3, #60704	; 0xed20
    2e1c:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2e20:	f64e 5220 	movw	r2, #60704	; 0xed20
    2e24:	f2ce 0200 	movt	r2, #57344	; 0xe000
    2e28:	6812      	ldr	r2, [r2, #0]
    2e2a:	f042 4278 	orr.w	r2, r2, #4160749568	; 0xf8000000
    2e2e:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
    2e30:	f000 f88c 	bl	2f4c <prvSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
    2e34:	f240 0308 	movw	r3, #8
    2e38:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2e3c:	f04f 0200 	mov.w	r2, #0
    2e40:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
    2e42:	f7ff ffd3 	bl	2dec <vPortStartFirstTask>

	/* Should not get here! */
	return 0;
    2e46:	f04f 0300 	mov.w	r3, #0
}
    2e4a:	4618      	mov	r0, r3
    2e4c:	46bd      	mov	sp, r7
    2e4e:	bd80      	pop	{r7, pc}

00002e50 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2e50:	b480      	push	{r7}
    2e52:	af00      	add	r7, sp, #0
	/* It is unlikely that the CM3 port will require this function as there
	is nothing to return to.  */
}
    2e54:	46bd      	mov	sp, r7
    2e56:	bc80      	pop	{r7}
    2e58:	4770      	bx	lr
    2e5a:	bf00      	nop

00002e5c <vPortYieldFromISR>:
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
    2e5c:	b480      	push	{r7}
    2e5e:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
    2e60:	f64e 5304 	movw	r3, #60676	; 0xed04
    2e64:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2e68:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    2e6c:	601a      	str	r2, [r3, #0]
}
    2e6e:	46bd      	mov	sp, r7
    2e70:	bc80      	pop	{r7}
    2e72:	4770      	bx	lr

00002e74 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    2e74:	b480      	push	{r7}
    2e76:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
    2e78:	f04f 0028 	mov.w	r0, #40	; 0x28
    2e7c:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
    2e80:	f240 0308 	movw	r3, #8
    2e84:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2e88:	681b      	ldr	r3, [r3, #0]
    2e8a:	f103 0201 	add.w	r2, r3, #1
    2e8e:	f240 0308 	movw	r3, #8
    2e92:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2e96:	601a      	str	r2, [r3, #0]
}
    2e98:	46bd      	mov	sp, r7
    2e9a:	bc80      	pop	{r7}
    2e9c:	4770      	bx	lr
    2e9e:	bf00      	nop

00002ea0 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
    2ea0:	b480      	push	{r7}
    2ea2:	af00      	add	r7, sp, #0
	uxCriticalNesting--;
    2ea4:	f240 0308 	movw	r3, #8
    2ea8:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2eac:	681b      	ldr	r3, [r3, #0]
    2eae:	f103 32ff 	add.w	r2, r3, #4294967295
    2eb2:	f240 0308 	movw	r3, #8
    2eb6:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2eba:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
    2ebc:	f240 0308 	movw	r3, #8
    2ec0:	f2c1 0300 	movt	r3, #4096	; 0x1000
    2ec4:	681b      	ldr	r3, [r3, #0]
    2ec6:	2b00      	cmp	r3, #0
    2ec8:	d103      	bne.n	2ed2 <vPortExitCritical+0x32>
	{
		portENABLE_INTERRUPTS();
    2eca:	f04f 0000 	mov.w	r0, #0
    2ece:	f380 8811 	msr	BASEPRI, r0
	}
}
    2ed2:	46bd      	mov	sp, r7
    2ed4:	bc80      	pop	{r7}
    2ed6:	4770      	bx	lr

00002ed8 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
    2ed8:	f3ef 8009 	mrs	r0, PSP
    2edc:	4b0c      	ldr	r3, [pc, #48]	; (2f10 <pxCurrentTCBConst>)
    2ede:	681a      	ldr	r2, [r3, #0]
    2ee0:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
    2ee4:	6010      	str	r0, [r2, #0]
    2ee6:	e92d 4008 	stmdb	sp!, {r3, lr}
    2eea:	f04f 0028 	mov.w	r0, #40	; 0x28
    2eee:	f380 8811 	msr	BASEPRI, r0
    2ef2:	f7ff fb85 	bl	2600 <vTaskSwitchContext>
    2ef6:	f04f 0000 	mov.w	r0, #0
    2efa:	f380 8811 	msr	BASEPRI, r0
    2efe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    2f02:	6819      	ldr	r1, [r3, #0]
    2f04:	6808      	ldr	r0, [r1, #0]
    2f06:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
    2f0a:	f380 8809 	msr	PSP, r0
    2f0e:	4770      	bx	lr

00002f10 <pxCurrentTCBConst>:
    2f10:	10000034 	.word	0x10000034

00002f14 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
    2f14:	b580      	push	{r7, lr}
    2f16:	b082      	sub	sp, #8
    2f18:	af00      	add	r7, sp, #0
unsigned long ulDummy;

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
    2f1a:	f64e 5304 	movw	r3, #60676	; 0xed04
    2f1e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2f22:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    2f26:	601a      	str	r2, [r3, #0]
	#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
    2f28:	f04f 0300 	mov.w	r3, #0
    2f2c:	607b      	str	r3, [r7, #4]
    2f2e:	f04f 0028 	mov.w	r0, #40	; 0x28
    2f32:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
    2f36:	f7ff fabb 	bl	24b0 <vTaskIncrementTick>
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
    2f3a:	f04f 0000 	mov.w	r0, #0
    2f3e:	f380 8811 	msr	BASEPRI, r0
}
    2f42:	f107 0708 	add.w	r7, r7, #8
    2f46:	46bd      	mov	sp, r7
    2f48:	bd80      	pop	{r7, pc}
    2f4a:	bf00      	nop

00002f4c <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
    2f4c:	b480      	push	{r7}
    2f4e:	af00      	add	r7, sp, #0
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
    2f50:	f24e 0314 	movw	r3, #57364	; 0xe014
    2f54:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2f58:	f248 22b7 	movw	r2, #33463	; 0x82b7
    2f5c:	f2c0 0201 	movt	r2, #1
    2f60:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
    2f62:	f24e 0310 	movw	r3, #57360	; 0xe010
    2f66:	f2ce 0300 	movt	r3, #57344	; 0xe000
    2f6a:	f04f 0207 	mov.w	r2, #7
    2f6e:	601a      	str	r2, [r3, #0]
}
    2f70:	46bd      	mov	sp, r7
    2f72:	bc80      	pop	{r7}
    2f74:	4770      	bx	lr
    2f76:	bf00      	nop

00002f78 <memcpy>:
    2f78:	2a03      	cmp	r2, #3
    2f7a:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
    2f7e:	d80b      	bhi.n	2f98 <memcpy+0x20>
    2f80:	b13a      	cbz	r2, 2f92 <memcpy+0x1a>
    2f82:	2300      	movs	r3, #0
    2f84:	f811 c003 	ldrb.w	ip, [r1, r3]
    2f88:	f800 c003 	strb.w	ip, [r0, r3]
    2f8c:	3301      	adds	r3, #1
    2f8e:	4293      	cmp	r3, r2
    2f90:	d1f8      	bne.n	2f84 <memcpy+0xc>
    2f92:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
    2f96:	4770      	bx	lr
    2f98:	1882      	adds	r2, r0, r2
    2f9a:	460c      	mov	r4, r1
    2f9c:	4603      	mov	r3, r0
    2f9e:	e003      	b.n	2fa8 <memcpy+0x30>
    2fa0:	f814 1c01 	ldrb.w	r1, [r4, #-1]
    2fa4:	f803 1c01 	strb.w	r1, [r3, #-1]
    2fa8:	f003 0603 	and.w	r6, r3, #3
    2fac:	4619      	mov	r1, r3
    2fae:	46a4      	mov	ip, r4
    2fb0:	3301      	adds	r3, #1
    2fb2:	3401      	adds	r4, #1
    2fb4:	2e00      	cmp	r6, #0
    2fb6:	d1f3      	bne.n	2fa0 <memcpy+0x28>
    2fb8:	f01c 0403 	ands.w	r4, ip, #3
    2fbc:	4663      	mov	r3, ip
    2fbe:	bf08      	it	eq
    2fc0:	ebc1 0c02 	rsbeq	ip, r1, r2
    2fc4:	d068      	beq.n	3098 <memcpy+0x120>
    2fc6:	4265      	negs	r5, r4
    2fc8:	f1c4 0a04 	rsb	sl, r4, #4
    2fcc:	eb0c 0705 	add.w	r7, ip, r5
    2fd0:	4633      	mov	r3, r6
    2fd2:	ea4f 0aca 	mov.w	sl, sl, lsl #3
    2fd6:	f85c 6005 	ldr.w	r6, [ip, r5]
    2fda:	ea4f 08c4 	mov.w	r8, r4, lsl #3
    2fde:	1a55      	subs	r5, r2, r1
    2fe0:	e008      	b.n	2ff4 <memcpy+0x7c>
    2fe2:	f857 4f04 	ldr.w	r4, [r7, #4]!
    2fe6:	4626      	mov	r6, r4
    2fe8:	fa04 f40a 	lsl.w	r4, r4, sl
    2fec:	ea49 0404 	orr.w	r4, r9, r4
    2ff0:	50cc      	str	r4, [r1, r3]
    2ff2:	3304      	adds	r3, #4
    2ff4:	185c      	adds	r4, r3, r1
    2ff6:	2d03      	cmp	r5, #3
    2ff8:	fa26 f908 	lsr.w	r9, r6, r8
    2ffc:	f1a5 0504 	sub.w	r5, r5, #4
    3000:	eb0c 0603 	add.w	r6, ip, r3
    3004:	dced      	bgt.n	2fe2 <memcpy+0x6a>
    3006:	2300      	movs	r3, #0
    3008:	e002      	b.n	3010 <memcpy+0x98>
    300a:	5cf1      	ldrb	r1, [r6, r3]
    300c:	54e1      	strb	r1, [r4, r3]
    300e:	3301      	adds	r3, #1
    3010:	1919      	adds	r1, r3, r4
    3012:	4291      	cmp	r1, r2
    3014:	d3f9      	bcc.n	300a <memcpy+0x92>
    3016:	e7bc      	b.n	2f92 <memcpy+0x1a>
    3018:	f853 4c40 	ldr.w	r4, [r3, #-64]
    301c:	f841 4c40 	str.w	r4, [r1, #-64]
    3020:	f853 4c3c 	ldr.w	r4, [r3, #-60]
    3024:	f841 4c3c 	str.w	r4, [r1, #-60]
    3028:	f853 4c38 	ldr.w	r4, [r3, #-56]
    302c:	f841 4c38 	str.w	r4, [r1, #-56]
    3030:	f853 4c34 	ldr.w	r4, [r3, #-52]
    3034:	f841 4c34 	str.w	r4, [r1, #-52]
    3038:	f853 4c30 	ldr.w	r4, [r3, #-48]
    303c:	f841 4c30 	str.w	r4, [r1, #-48]
    3040:	f853 4c2c 	ldr.w	r4, [r3, #-44]
    3044:	f841 4c2c 	str.w	r4, [r1, #-44]
    3048:	f853 4c28 	ldr.w	r4, [r3, #-40]
    304c:	f841 4c28 	str.w	r4, [r1, #-40]
    3050:	f853 4c24 	ldr.w	r4, [r3, #-36]
    3054:	f841 4c24 	str.w	r4, [r1, #-36]
    3058:	f853 4c20 	ldr.w	r4, [r3, #-32]
    305c:	f841 4c20 	str.w	r4, [r1, #-32]
    3060:	f853 4c1c 	ldr.w	r4, [r3, #-28]
    3064:	f841 4c1c 	str.w	r4, [r1, #-28]
    3068:	f853 4c18 	ldr.w	r4, [r3, #-24]
    306c:	f841 4c18 	str.w	r4, [r1, #-24]
    3070:	f853 4c14 	ldr.w	r4, [r3, #-20]
    3074:	f841 4c14 	str.w	r4, [r1, #-20]
    3078:	f853 4c10 	ldr.w	r4, [r3, #-16]
    307c:	f841 4c10 	str.w	r4, [r1, #-16]
    3080:	f853 4c0c 	ldr.w	r4, [r3, #-12]
    3084:	f841 4c0c 	str.w	r4, [r1, #-12]
    3088:	f853 4c08 	ldr.w	r4, [r3, #-8]
    308c:	f841 4c08 	str.w	r4, [r1, #-8]
    3090:	f853 4c04 	ldr.w	r4, [r3, #-4]
    3094:	f841 4c04 	str.w	r4, [r1, #-4]
    3098:	461c      	mov	r4, r3
    309a:	460d      	mov	r5, r1
    309c:	3340      	adds	r3, #64	; 0x40
    309e:	3140      	adds	r1, #64	; 0x40
    30a0:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
    30a4:	f1ac 0c40 	sub.w	ip, ip, #64	; 0x40
    30a8:	dcb6      	bgt.n	3018 <memcpy+0xa0>
    30aa:	4621      	mov	r1, r4
    30ac:	462b      	mov	r3, r5
    30ae:	1b54      	subs	r4, r2, r5
    30b0:	e00f      	b.n	30d2 <memcpy+0x15a>
    30b2:	f851 5c10 	ldr.w	r5, [r1, #-16]
    30b6:	f843 5c10 	str.w	r5, [r3, #-16]
    30ba:	f851 5c0c 	ldr.w	r5, [r1, #-12]
    30be:	f843 5c0c 	str.w	r5, [r3, #-12]
    30c2:	f851 5c08 	ldr.w	r5, [r1, #-8]
    30c6:	f843 5c08 	str.w	r5, [r3, #-8]
    30ca:	f851 5c04 	ldr.w	r5, [r1, #-4]
    30ce:	f843 5c04 	str.w	r5, [r3, #-4]
    30d2:	2c0f      	cmp	r4, #15
    30d4:	460d      	mov	r5, r1
    30d6:	469c      	mov	ip, r3
    30d8:	f101 0110 	add.w	r1, r1, #16
    30dc:	f103 0310 	add.w	r3, r3, #16
    30e0:	f1a4 0410 	sub.w	r4, r4, #16
    30e4:	dce5      	bgt.n	30b2 <memcpy+0x13a>
    30e6:	ebcc 0102 	rsb	r1, ip, r2
    30ea:	2300      	movs	r3, #0
    30ec:	e003      	b.n	30f6 <memcpy+0x17e>
    30ee:	58ec      	ldr	r4, [r5, r3]
    30f0:	f84c 4003 	str.w	r4, [ip, r3]
    30f4:	3304      	adds	r3, #4
    30f6:	195e      	adds	r6, r3, r5
    30f8:	2903      	cmp	r1, #3
    30fa:	eb03 040c 	add.w	r4, r3, ip
    30fe:	f1a1 0104 	sub.w	r1, r1, #4
    3102:	dcf4      	bgt.n	30ee <memcpy+0x176>
    3104:	e77f      	b.n	3006 <memcpy+0x8e>
    3106:	bf00      	nop

00003108 <memset>:
    3108:	2a03      	cmp	r2, #3
    310a:	b2c9      	uxtb	r1, r1
    310c:	b430      	push	{r4, r5}
    310e:	d807      	bhi.n	3120 <memset+0x18>
    3110:	b122      	cbz	r2, 311c <memset+0x14>
    3112:	2300      	movs	r3, #0
    3114:	54c1      	strb	r1, [r0, r3]
    3116:	3301      	adds	r3, #1
    3118:	4293      	cmp	r3, r2
    311a:	d1fb      	bne.n	3114 <memset+0xc>
    311c:	bc30      	pop	{r4, r5}
    311e:	4770      	bx	lr
    3120:	eb00 0c02 	add.w	ip, r0, r2
    3124:	4603      	mov	r3, r0
    3126:	e001      	b.n	312c <memset+0x24>
    3128:	f803 1c01 	strb.w	r1, [r3, #-1]
    312c:	f003 0403 	and.w	r4, r3, #3
    3130:	461a      	mov	r2, r3
    3132:	3301      	adds	r3, #1
    3134:	2c00      	cmp	r4, #0
    3136:	d1f7      	bne.n	3128 <memset+0x20>
    3138:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
    313c:	ebc2 040c 	rsb	r4, r2, ip
    3140:	fb03 f301 	mul.w	r3, r3, r1
    3144:	e01f      	b.n	3186 <memset+0x7e>
    3146:	f842 3c40 	str.w	r3, [r2, #-64]
    314a:	f842 3c3c 	str.w	r3, [r2, #-60]
    314e:	f842 3c38 	str.w	r3, [r2, #-56]
    3152:	f842 3c34 	str.w	r3, [r2, #-52]
    3156:	f842 3c30 	str.w	r3, [r2, #-48]
    315a:	f842 3c2c 	str.w	r3, [r2, #-44]
    315e:	f842 3c28 	str.w	r3, [r2, #-40]
    3162:	f842 3c24 	str.w	r3, [r2, #-36]
    3166:	f842 3c20 	str.w	r3, [r2, #-32]
    316a:	f842 3c1c 	str.w	r3, [r2, #-28]
    316e:	f842 3c18 	str.w	r3, [r2, #-24]
    3172:	f842 3c14 	str.w	r3, [r2, #-20]
    3176:	f842 3c10 	str.w	r3, [r2, #-16]
    317a:	f842 3c0c 	str.w	r3, [r2, #-12]
    317e:	f842 3c08 	str.w	r3, [r2, #-8]
    3182:	f842 3c04 	str.w	r3, [r2, #-4]
    3186:	4615      	mov	r5, r2
    3188:	3240      	adds	r2, #64	; 0x40
    318a:	2c3f      	cmp	r4, #63	; 0x3f
    318c:	f1a4 0440 	sub.w	r4, r4, #64	; 0x40
    3190:	dcd9      	bgt.n	3146 <memset+0x3e>
    3192:	462a      	mov	r2, r5
    3194:	ebc5 040c 	rsb	r4, r5, ip
    3198:	e007      	b.n	31aa <memset+0xa2>
    319a:	f842 3c10 	str.w	r3, [r2, #-16]
    319e:	f842 3c0c 	str.w	r3, [r2, #-12]
    31a2:	f842 3c08 	str.w	r3, [r2, #-8]
    31a6:	f842 3c04 	str.w	r3, [r2, #-4]
    31aa:	4615      	mov	r5, r2
    31ac:	3210      	adds	r2, #16
    31ae:	2c0f      	cmp	r4, #15
    31b0:	f1a4 0410 	sub.w	r4, r4, #16
    31b4:	dcf1      	bgt.n	319a <memset+0x92>
    31b6:	462a      	mov	r2, r5
    31b8:	ebc5 050c 	rsb	r5, r5, ip
    31bc:	e001      	b.n	31c2 <memset+0xba>
    31be:	f842 3c04 	str.w	r3, [r2, #-4]
    31c2:	4614      	mov	r4, r2
    31c4:	3204      	adds	r2, #4
    31c6:	2d03      	cmp	r5, #3
    31c8:	f1a5 0504 	sub.w	r5, r5, #4
    31cc:	dcf7      	bgt.n	31be <memset+0xb6>
    31ce:	e001      	b.n	31d4 <memset+0xcc>
    31d0:	f804 1b01 	strb.w	r1, [r4], #1
    31d4:	4564      	cmp	r4, ip
    31d6:	d3fb      	bcc.n	31d0 <memset+0xc8>
    31d8:	e7a0      	b.n	311c <memset+0x14>
    31da:	bf00      	nop

000031dc <strncpy>:
    31dc:	ea41 0300 	orr.w	r3, r1, r0
    31e0:	f013 0f03 	tst.w	r3, #3
    31e4:	bf14      	ite	ne
    31e6:	2300      	movne	r3, #0
    31e8:	2301      	moveq	r3, #1
    31ea:	2a03      	cmp	r2, #3
    31ec:	bf94      	ite	ls
    31ee:	2300      	movls	r3, #0
    31f0:	f003 0301 	andhi.w	r3, r3, #1
    31f4:	b430      	push	{r4, r5}
    31f6:	2b00      	cmp	r3, #0
    31f8:	d02a      	beq.n	3250 <strncpy+0x74>
    31fa:	4604      	mov	r4, r0
    31fc:	680b      	ldr	r3, [r1, #0]
    31fe:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
    3202:	ea2c 0c03 	bic.w	ip, ip, r3
    3206:	f01c 3f80 	tst.w	ip, #2155905152	; 0x80808080
    320a:	d105      	bne.n	3218 <strncpy+0x3c>
    320c:	3a04      	subs	r2, #4
    320e:	3104      	adds	r1, #4
    3210:	2a03      	cmp	r2, #3
    3212:	f844 3b04 	str.w	r3, [r4], #4
    3216:	d8f1      	bhi.n	31fc <strncpy+0x20>
    3218:	4623      	mov	r3, r4
    321a:	b1ba      	cbz	r2, 324c <strncpy+0x70>
    321c:	780d      	ldrb	r5, [r1, #0]
    321e:	461c      	mov	r4, r3
    3220:	3a01      	subs	r2, #1
    3222:	f804 5b01 	strb.w	r5, [r4], #1
    3226:	b155      	cbz	r5, 323e <strncpy+0x62>
    3228:	3302      	adds	r3, #2
    322a:	b17a      	cbz	r2, 324c <strncpy+0x70>
    322c:	f811 5f01 	ldrb.w	r5, [r1, #1]!
    3230:	461c      	mov	r4, r3
    3232:	3a01      	subs	r2, #1
    3234:	f803 5c01 	strb.w	r5, [r3, #-1]
    3238:	3301      	adds	r3, #1
    323a:	2d00      	cmp	r5, #0
    323c:	d1f5      	bne.n	322a <strncpy+0x4e>
    323e:	b12a      	cbz	r2, 324c <strncpy+0x70>
    3240:	2300      	movs	r3, #0
    3242:	4619      	mov	r1, r3
    3244:	54e1      	strb	r1, [r4, r3]
    3246:	3301      	adds	r3, #1
    3248:	4293      	cmp	r3, r2
    324a:	d1fb      	bne.n	3244 <strncpy+0x68>
    324c:	bc30      	pop	{r4, r5}
    324e:	4770      	bx	lr
    3250:	4603      	mov	r3, r0
    3252:	e7e2      	b.n	321a <strncpy+0x3e>
    3254:	0044454c 	.word	0x0044454c
    3258:	6c756e28 	.word	0x6c756e28
    325c:	0000296c 	.word	0x0000296c
    3260:	454c4449 	.word	0x454c4449
    3264:	00000000 	.word	0x00000000

00003268 <heapSTRUCT_SIZE>:
    3268:	00000010                                ....

0000326c <ulKernelPriority>:
    326c:	000000f8                                ....

Disassembly of section .init:

00003270 <_init>:
    3270:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3272:	bf00      	nop
    3274:	bcf8      	pop	{r3, r4, r5, r6, r7}
    3276:	bc08      	pop	{r3}
    3278:	469e      	mov	lr, r3
    327a:	4770      	bx	lr

Disassembly of section .fini:

0000327c <_fini>:
    327c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    327e:	bf00      	nop
    3280:	bcf8      	pop	{r3, r4, r5, r6, r7}
    3282:	bc08      	pop	{r3}
    3284:	469e      	mov	lr, r3
    3286:	4770      	bx	lr
